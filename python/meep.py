# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _meep
else:
    import _meep

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_SwigPyIterator

    def value(self):
        return _meep.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _meep.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _meep.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _meep.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _meep.SwigPyIterator_equal(self, x)

    def copy(self):
        return _meep.SwigPyIterator_copy(self)

    def next(self):
        return _meep.SwigPyIterator_next(self)

    def __next__(self):
        return _meep.SwigPyIterator___next__(self)

    def previous(self):
        return _meep.SwigPyIterator_previous(self)

    def advance(self, n):
        return _meep.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _meep.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _meep.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _meep.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _meep.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _meep.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _meep.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _meep:
_meep.SwigPyIterator_swigregister(SwigPyIterator)

py_pml_profile = _meep.py_pml_profile
py_master_printf_wrap = _meep.py_master_printf_wrap
py_master_printf_stderr_wrap = _meep.py_master_printf_stderr_wrap

def set_ctl_printf_callback(callback):
    return _meep.set_ctl_printf_callback(callback)

def set_mpb_printf_callback(callback):
    return _meep.set_mpb_printf_callback(callback)

def py_do_harminv(vals, dt, f_min, f_max, maxbands, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh):
    return _meep.py_do_harminv(vals, dt, f_min, f_max, maxbands, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh)

def _get_farfield(f, v):
    return _meep._get_farfield(f, v)

def _get_farfields_array(n2f, where, resolution):
    return _meep._get_farfields_array(n2f, where, resolution)

def _dft_ldos_ldos(f):
    return _meep._dft_ldos_ldos(f)

def _dft_ldos_F(f):
    return _meep._dft_ldos_F(f)

def _dft_ldos_J(f):
    return _meep._dft_ldos_J(f)

def _get_dft_data_size(dc):
    return _meep._get_dft_data_size(dc)

def _get_dft_data(dc, cdata):
    return _meep._get_dft_data(dc, cdata)

def _load_dft_data(dc, cdata):
    return _meep._load_dft_data(dc, cdata)

def make_volume_list(v, c, weight, next):
    return _meep.make_volume_list(v, c, weight, next)

def _get_gradient(grad, fields_a, fields_f, grid_volume, frequencies, py_geom_list, f):
    return _meep._get_gradient(grad, fields_a, fields_f, grid_volume, frequencies, py_geom_list, f)

def get_dft_flux_array(f, dft, c, num_freq):
    return _meep.get_dft_flux_array(f, dft, c, num_freq)

def get_dft_fields_array(f, dft, c, num_freq):
    return _meep.get_dft_fields_array(f, dft, c, num_freq)

def get_dft_force_array(f, dft, c, num_freq):
    return _meep.get_dft_force_array(f, dft, c, num_freq)

def get_dft_near2far_array(f, dft, c, num_freq):
    return _meep.get_dft_near2far_array(f, dft, c, num_freq)
class FragmentStatsVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.FragmentStatsVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.FragmentStatsVector___nonzero__(self)

    def __bool__(self):
        return _meep.FragmentStatsVector___bool__(self)

    def __len__(self):
        return _meep.FragmentStatsVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.FragmentStatsVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.FragmentStatsVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.FragmentStatsVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.FragmentStatsVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.FragmentStatsVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.FragmentStatsVector___setitem__(self, *args)

    def pop(self):
        return _meep.FragmentStatsVector_pop(self)

    def append(self, x):
        return _meep.FragmentStatsVector_append(self, x)

    def empty(self):
        return _meep.FragmentStatsVector_empty(self)

    def size(self):
        return _meep.FragmentStatsVector_size(self)

    def swap(self, v):
        return _meep.FragmentStatsVector_swap(self, v)

    def begin(self):
        return _meep.FragmentStatsVector_begin(self)

    def end(self):
        return _meep.FragmentStatsVector_end(self)

    def rbegin(self):
        return _meep.FragmentStatsVector_rbegin(self)

    def rend(self):
        return _meep.FragmentStatsVector_rend(self)

    def clear(self):
        return _meep.FragmentStatsVector_clear(self)

    def get_allocator(self):
        return _meep.FragmentStatsVector_get_allocator(self)

    def pop_back(self):
        return _meep.FragmentStatsVector_pop_back(self)

    def erase(self, *args):
        return _meep.FragmentStatsVector_erase(self, *args)

    def __init__(self, *args):
        _meep.FragmentStatsVector_swiginit(self, _meep.new_FragmentStatsVector(*args))

    def push_back(self, x):
        return _meep.FragmentStatsVector_push_back(self, x)

    def front(self):
        return _meep.FragmentStatsVector_front(self)

    def back(self):
        return _meep.FragmentStatsVector_back(self)

    def assign(self, n, x):
        return _meep.FragmentStatsVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.FragmentStatsVector_resize(self, *args)

    def insert(self, *args):
        return _meep.FragmentStatsVector_insert(self, *args)

    def reserve(self, n):
        return _meep.FragmentStatsVector_reserve(self, n)

    def capacity(self):
        return _meep.FragmentStatsVector_capacity(self)
    __swig_destroy__ = _meep.delete_FragmentStatsVector

# Register FragmentStatsVector in _meep:
_meep.FragmentStatsVector_swigregister(FragmentStatsVector)

class DftDataVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.DftDataVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.DftDataVector___nonzero__(self)

    def __bool__(self):
        return _meep.DftDataVector___bool__(self)

    def __len__(self):
        return _meep.DftDataVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.DftDataVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.DftDataVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.DftDataVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.DftDataVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.DftDataVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.DftDataVector___setitem__(self, *args)

    def pop(self):
        return _meep.DftDataVector_pop(self)

    def append(self, x):
        return _meep.DftDataVector_append(self, x)

    def empty(self):
        return _meep.DftDataVector_empty(self)

    def size(self):
        return _meep.DftDataVector_size(self)

    def swap(self, v):
        return _meep.DftDataVector_swap(self, v)

    def begin(self):
        return _meep.DftDataVector_begin(self)

    def end(self):
        return _meep.DftDataVector_end(self)

    def rbegin(self):
        return _meep.DftDataVector_rbegin(self)

    def rend(self):
        return _meep.DftDataVector_rend(self)

    def clear(self):
        return _meep.DftDataVector_clear(self)

    def get_allocator(self):
        return _meep.DftDataVector_get_allocator(self)

    def pop_back(self):
        return _meep.DftDataVector_pop_back(self)

    def erase(self, *args):
        return _meep.DftDataVector_erase(self, *args)

    def __init__(self, *args):
        _meep.DftDataVector_swiginit(self, _meep.new_DftDataVector(*args))

    def push_back(self, x):
        return _meep.DftDataVector_push_back(self, x)

    def front(self):
        return _meep.DftDataVector_front(self)

    def back(self):
        return _meep.DftDataVector_back(self)

    def assign(self, n, x):
        return _meep.DftDataVector_assign(self, n, x)

    def insert(self, *args):
        return _meep.DftDataVector_insert(self, *args)

    def reserve(self, n):
        return _meep.DftDataVector_reserve(self, n)

    def capacity(self):
        return _meep.DftDataVector_capacity(self)
    __swig_destroy__ = _meep.delete_DftDataVector

# Register DftDataVector in _meep:
_meep.DftDataVector_swigregister(DftDataVector)

class VolumeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.VolumeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.VolumeVector___nonzero__(self)

    def __bool__(self):
        return _meep.VolumeVector___bool__(self)

    def __len__(self):
        return _meep.VolumeVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.VolumeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.VolumeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.VolumeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.VolumeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.VolumeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.VolumeVector___setitem__(self, *args)

    def pop(self):
        return _meep.VolumeVector_pop(self)

    def append(self, x):
        return _meep.VolumeVector_append(self, x)

    def empty(self):
        return _meep.VolumeVector_empty(self)

    def size(self):
        return _meep.VolumeVector_size(self)

    def swap(self, v):
        return _meep.VolumeVector_swap(self, v)

    def begin(self):
        return _meep.VolumeVector_begin(self)

    def end(self):
        return _meep.VolumeVector_end(self)

    def rbegin(self):
        return _meep.VolumeVector_rbegin(self)

    def rend(self):
        return _meep.VolumeVector_rend(self)

    def clear(self):
        return _meep.VolumeVector_clear(self)

    def get_allocator(self):
        return _meep.VolumeVector_get_allocator(self)

    def pop_back(self):
        return _meep.VolumeVector_pop_back(self)

    def erase(self, *args):
        return _meep.VolumeVector_erase(self, *args)

    def __init__(self, *args):
        _meep.VolumeVector_swiginit(self, _meep.new_VolumeVector(*args))

    def push_back(self, x):
        return _meep.VolumeVector_push_back(self, x)

    def front(self):
        return _meep.VolumeVector_front(self)

    def back(self):
        return _meep.VolumeVector_back(self)

    def assign(self, n, x):
        return _meep.VolumeVector_assign(self, n, x)

    def insert(self, *args):
        return _meep.VolumeVector_insert(self, *args)

    def reserve(self, n):
        return _meep.VolumeVector_reserve(self, n)

    def capacity(self):
        return _meep.VolumeVector_capacity(self)
    __swig_destroy__ = _meep.delete_VolumeVector

# Register VolumeVector in _meep:
_meep.VolumeVector_swigregister(VolumeVector)

class GridVolumeVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.GridVolumeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.GridVolumeVector___nonzero__(self)

    def __bool__(self):
        return _meep.GridVolumeVector___bool__(self)

    def __len__(self):
        return _meep.GridVolumeVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.GridVolumeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.GridVolumeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.GridVolumeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.GridVolumeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.GridVolumeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.GridVolumeVector___setitem__(self, *args)

    def pop(self):
        return _meep.GridVolumeVector_pop(self)

    def append(self, x):
        return _meep.GridVolumeVector_append(self, x)

    def empty(self):
        return _meep.GridVolumeVector_empty(self)

    def size(self):
        return _meep.GridVolumeVector_size(self)

    def swap(self, v):
        return _meep.GridVolumeVector_swap(self, v)

    def begin(self):
        return _meep.GridVolumeVector_begin(self)

    def end(self):
        return _meep.GridVolumeVector_end(self)

    def rbegin(self):
        return _meep.GridVolumeVector_rbegin(self)

    def rend(self):
        return _meep.GridVolumeVector_rend(self)

    def clear(self):
        return _meep.GridVolumeVector_clear(self)

    def get_allocator(self):
        return _meep.GridVolumeVector_get_allocator(self)

    def pop_back(self):
        return _meep.GridVolumeVector_pop_back(self)

    def erase(self, *args):
        return _meep.GridVolumeVector_erase(self, *args)

    def __init__(self, *args):
        _meep.GridVolumeVector_swiginit(self, _meep.new_GridVolumeVector(*args))

    def push_back(self, x):
        return _meep.GridVolumeVector_push_back(self, x)

    def front(self):
        return _meep.GridVolumeVector_front(self)

    def back(self):
        return _meep.GridVolumeVector_back(self)

    def assign(self, n, x):
        return _meep.GridVolumeVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.GridVolumeVector_resize(self, *args)

    def insert(self, *args):
        return _meep.GridVolumeVector_insert(self, *args)

    def reserve(self, n):
        return _meep.GridVolumeVector_reserve(self, n)

    def capacity(self):
        return _meep.GridVolumeVector_capacity(self)
    __swig_destroy__ = _meep.delete_GridVolumeVector

# Register GridVolumeVector in _meep:
_meep.GridVolumeVector_swigregister(GridVolumeVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.IntVector___nonzero__(self)

    def __bool__(self):
        return _meep.IntVector___bool__(self)

    def __len__(self):
        return _meep.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.IntVector___setitem__(self, *args)

    def pop(self):
        return _meep.IntVector_pop(self)

    def append(self, x):
        return _meep.IntVector_append(self, x)

    def empty(self):
        return _meep.IntVector_empty(self)

    def size(self):
        return _meep.IntVector_size(self)

    def swap(self, v):
        return _meep.IntVector_swap(self, v)

    def begin(self):
        return _meep.IntVector_begin(self)

    def end(self):
        return _meep.IntVector_end(self)

    def rbegin(self):
        return _meep.IntVector_rbegin(self)

    def rend(self):
        return _meep.IntVector_rend(self)

    def clear(self):
        return _meep.IntVector_clear(self)

    def get_allocator(self):
        return _meep.IntVector_get_allocator(self)

    def pop_back(self):
        return _meep.IntVector_pop_back(self)

    def erase(self, *args):
        return _meep.IntVector_erase(self, *args)

    def __init__(self, *args):
        _meep.IntVector_swiginit(self, _meep.new_IntVector(*args))

    def push_back(self, x):
        return _meep.IntVector_push_back(self, x)

    def front(self):
        return _meep.IntVector_front(self)

    def back(self):
        return _meep.IntVector_back(self)

    def assign(self, n, x):
        return _meep.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.IntVector_resize(self, *args)

    def insert(self, *args):
        return _meep.IntVector_insert(self, *args)

    def reserve(self, n):
        return _meep.IntVector_reserve(self, n)

    def capacity(self):
        return _meep.IntVector_capacity(self)
    __swig_destroy__ = _meep.delete_IntVector

# Register IntVector in _meep:
_meep.IntVector_swigregister(IntVector)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _meep.DoubleVector___bool__(self)

    def __len__(self):
        return _meep.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _meep.DoubleVector_pop(self)

    def append(self, x):
        return _meep.DoubleVector_append(self, x)

    def empty(self):
        return _meep.DoubleVector_empty(self)

    def size(self):
        return _meep.DoubleVector_size(self)

    def swap(self, v):
        return _meep.DoubleVector_swap(self, v)

    def begin(self):
        return _meep.DoubleVector_begin(self)

    def end(self):
        return _meep.DoubleVector_end(self)

    def rbegin(self):
        return _meep.DoubleVector_rbegin(self)

    def rend(self):
        return _meep.DoubleVector_rend(self)

    def clear(self):
        return _meep.DoubleVector_clear(self)

    def get_allocator(self):
        return _meep.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _meep.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _meep.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _meep.DoubleVector_swiginit(self, _meep.new_DoubleVector(*args))

    def push_back(self, x):
        return _meep.DoubleVector_push_back(self, x)

    def front(self):
        return _meep.DoubleVector_front(self)

    def back(self):
        return _meep.DoubleVector_back(self)

    def assign(self, n, x):
        return _meep.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _meep.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _meep.DoubleVector_reserve(self, n)

    def capacity(self):
        return _meep.DoubleVector_capacity(self)
    __swig_destroy__ = _meep.delete_DoubleVector

# Register DoubleVector in _meep:
_meep.DoubleVector_swigregister(DoubleVector)

Ex = _meep.Ex
Ey = _meep.Ey
Er = _meep.Er
Ep = _meep.Ep
Ez = _meep.Ez
Hx = _meep.Hx
Hy = _meep.Hy
Hr = _meep.Hr
Hp = _meep.Hp
Hz = _meep.Hz
Dx = _meep.Dx
Dy = _meep.Dy
Dr = _meep.Dr
Dp = _meep.Dp
Dz = _meep.Dz
Bx = _meep.Bx
By = _meep.By
Br = _meep.Br
Bp = _meep.Bp
Bz = _meep.Bz
Dielectric = _meep.Dielectric
Permeability = _meep.Permeability
NO_COMPONENT = _meep.NO_COMPONENT
Sx = _meep.Sx
Sy = _meep.Sy
Sr = _meep.Sr
Sp = _meep.Sp
Sz = _meep.Sz
EnergyDensity = _meep.EnergyDensity
D_EnergyDensity = _meep.D_EnergyDensity
H_EnergyDensity = _meep.H_EnergyDensity
D1 = _meep.D1
D2 = _meep.D2
D3 = _meep.D3
Dcyl = _meep.Dcyl
E_stuff = _meep.E_stuff
H_stuff = _meep.H_stuff
D_stuff = _meep.D_stuff
B_stuff = _meep.B_stuff
PE_stuff = _meep.PE_stuff
PH_stuff = _meep.PH_stuff
WE_stuff = _meep.WE_stuff
WH_stuff = _meep.WH_stuff
High = _meep.High
Low = _meep.Low
X = _meep.X
Y = _meep.Y
Z = _meep.Z
R = _meep.R
P = _meep.P
NO_DIRECTION = _meep.NO_DIRECTION
class signed_direction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.signed_direction_swiginit(self, _meep.new_signed_direction(*args))

    def __mul__(self, ph):
        return _meep.signed_direction___mul__(self, ph)

    def __eq__(self, sd):
        return _meep.signed_direction___eq__(self, sd)

    def __ne__(self, sd):
        return _meep.signed_direction___ne__(self, sd)
    d = property(_meep.signed_direction_d_get, _meep.signed_direction_d_set)
    flipped = property(_meep.signed_direction_flipped_get, _meep.signed_direction_flipped_set)
    phase = property(_meep.signed_direction_phase_get, _meep.signed_direction_phase_set)
    __swig_destroy__ = _meep.delete_signed_direction

# Register signed_direction in _meep:
_meep.signed_direction_swigregister(signed_direction)
cvar = _meep.cvar
NUM_FIELD_COMPONENTS = cvar.NUM_FIELD_COMPONENTS
NUM_FIELD_TYPES = cvar.NUM_FIELD_TYPES


def number_of_directions(dim):
    return _meep.number_of_directions(dim)

def start_at_direction(dim):
    return _meep.start_at_direction(dim)

def stop_at_direction(dim):
    return _meep.stop_at_direction(dim)

def first_field_component(ft):
    return _meep.first_field_component(ft)

def flip(d):
    return _meep.flip(d)

def has_direction(dim, d):
    return _meep.has_direction(dim, d)

def has_field_direction(dim, d):
    return _meep.has_field_direction(dim, d)

def is_tm(c):
    return _meep.is_tm(c)

def abort(*args):
    return _meep.abort(*args)

def is_electric(c):
    return _meep.is_electric(c)

def is_magnetic(c):
    return _meep.is_magnetic(c)

def is_D(c):
    return _meep.is_D(c)

def is_B(c):
    return _meep.is_B(c)

def is_derived(c):
    return _meep.is_derived(c)

def is_poynting(c):
    return _meep.is_poynting(c)

def is_energydensity(c):
    return _meep.is_energydensity(c)

def meep_type(c):
    return _meep.meep_type(c)

def component_name(*args):
    return _meep.component_name(*args)

def direction_name(arg1):
    return _meep.direction_name(arg1)

def dimension_name(arg1):
    return _meep.dimension_name(arg1)

def component_index(c):
    return _meep.component_index(c)

def component_direction(*args):
    return _meep.component_direction(*args)

def direction_component(*args):
    return _meep.direction_component(*args)

def field_type_component(ft, c):
    return _meep.field_type_component(ft, c)

def coordinate_mismatch(*args):
    return _meep.coordinate_mismatch(*args)

def cycle_direction(dim, d, shift):
    return _meep.cycle_direction(dim, d, shift)

def cycle_component(dim, c, shift):
    return _meep.cycle_component(dim, c, shift)

def veccyl(rr, zz):
    return _meep.veccyl(rr, zz)

def zero_vec(arg1):
    return _meep.zero_vec(arg1)
class vec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __swig_destroy__ = _meep.delete_vec

    def __add__(self, a):
        return _meep.vec___add__(self, a)

    def __iadd__(self, a):
        return _meep.vec___iadd__(self, a)

    def __sub__(self, a):
        return _meep.vec___sub__(self, a)

    def __neg__(self):
        return _meep.vec___neg__(self)

    def __isub__(self, a):
        return _meep.vec___isub__(self, a)

    def __ne__(self, a):
        return _meep.vec___ne__(self, a)

    def __eq__(self, a):
        return _meep.vec___eq__(self, a)

    def round_float(self):
        return _meep.vec_round_float(self)

    def __mul__(self, s):
        return _meep.vec___mul__(self, s)

    def __truediv__(self, *args):
        return _meep.vec___truediv__(self, *args)
    __div__ = __truediv__



    def __and__(self, a):
        return _meep.vec___and__(self, a)
    dim = property(_meep.vec_dim_get, _meep.vec_dim_set)

    def r(self):
        return _meep.vec_r(self)

    def x(self):
        return _meep.vec_x(self)

    def y(self):
        return _meep.vec_y(self)

    def z(self):
        return _meep.vec_z(self)

    def in_direction(self, d):
        return _meep.vec_in_direction(self, d)

    def set_direction(self, d, val):
        return _meep.vec_set_direction(self, d, val)

    def project_to_boundary(self, arg2, boundary_loc):
        return _meep.vec_project_to_boundary(self, arg2, boundary_loc)

    def __repr__(self):
        return _meep.vec___repr__(self)

# Register vec in _meep:
_meep.vec_swigregister(vec)

def vec_dim(di):
    val = _meep.new_vec_dim(di)
    return val

def vec_dim_val(di, val):
    val = _meep.new_vec_dim_val(di, val)
    return val

def _vec(*args):
    val = _meep.new__vec(*args)
    return val


def vec_abs(pt):
    return _meep.vec_abs(pt)

def one_vec(di):
    return _meep.one_vec(di)

def unit_vec(di, d):
    return _meep.unit_vec(di, d)

def clean_vec(pt, val_unused=0.0):
    return _meep.clean_vec(pt, val_unused)

def iveccyl(xx, yy):
    return _meep.iveccyl(xx, yy)

def zero_ivec(arg1):
    return _meep.zero_ivec(arg1)

def one_ivec(arg1):
    return _meep.one_ivec(arg1)
class ivec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args):
        _meep.ivec_swiginit(self, _meep.new_ivec(*args))
    __swig_destroy__ = _meep.delete_ivec

    def yucky_val(self, arg2):
        return _meep.ivec_yucky_val(self, arg2)

    def __add__(self, a):
        return _meep.ivec___add__(self, a)

    def __iadd__(self, a):
        return _meep.ivec___iadd__(self, a)

    def __sub__(self, a):
        return _meep.ivec___sub__(self, a)

    def __neg__(self):
        return _meep.ivec___neg__(self)

    def __isub__(self, a):
        return _meep.ivec___isub__(self, a)

    def __ne__(self, a):
        return _meep.ivec___ne__(self, a)

    def __eq__(self, a):
        return _meep.ivec___eq__(self, a)

    def __le__(self, a):
        return _meep.ivec___le__(self, a)

    def __ge__(self, a):
        return _meep.ivec___ge__(self, a)

    def __lt__(self, a):
        return _meep.ivec___lt__(self, a)

    def __gt__(self, a):
        return _meep.ivec___gt__(self, a)

    def __mul__(self, *args):
        return _meep.ivec___mul__(self, *args)
    dim = property(_meep.ivec_dim_get, _meep.ivec_dim_set)

    def r(self):
        return _meep.ivec_r(self)

    def x(self):
        return _meep.ivec_x(self)

    def y(self):
        return _meep.ivec_y(self)

    def z(self):
        return _meep.ivec_z(self)

    def in_direction(self, d):
        return _meep.ivec_in_direction(self, d)

    def set_direction(self, d, val):
        return _meep.ivec_set_direction(self, d, val)

    def round_up_to_even(self):
        return _meep.ivec_round_up_to_even(self)

    def __repr__(self):
        return _meep.ivec___repr__(self)

# Register ivec in _meep:
_meep.ivec_swigregister(ivec)


def unit_ivec(di, d):
    return _meep.unit_ivec(di, d)

def vec_max(*args):
    return _meep.vec_max(*args)

def vec_min(*args):
    return _meep.vec_min(*args)
class volume(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    dim = property(_meep.volume_dim_get, _meep.volume_dim_set)

    def __init__(self, *args):
        _meep.volume_swiginit(self, _meep.new_volume(*args))

    def set_direction_min(self, d, val):
        return _meep.volume_set_direction_min(self, d, val)

    def set_direction_max(self, d, val):
        return _meep.volume_set_direction_max(self, d, val)

    def in_direction_min(self, d):
        return _meep.volume_in_direction_min(self, d)

    def in_direction_max(self, d):
        return _meep.volume_in_direction_max(self, d)

    def in_direction(self, d):
        return _meep.volume_in_direction(self, d)

    def computational_volume(self):
        return _meep.volume_computational_volume(self)

    def integral_volume(self):
        return _meep.volume_integral_volume(self)

    def full_volume(self):
        return _meep.volume_full_volume(self)

    def center(self):
        return _meep.volume_center(self)

    def diameter(self):
        return _meep.volume_diameter(self)

    def contains(self, *args):
        return _meep.volume_contains(self, *args)

    def intersect_with(self, a):
        return _meep.volume_intersect_with(self, a)

    def __and__(self, a):
        return _meep.volume___and__(self, a)

    def __or__(self, a):
        return _meep.volume___or__(self, a)

    def __add__(self, a):
        return _meep.volume___add__(self, a)

    def __iadd__(self, a):
        return _meep.volume___iadd__(self, a)

    def __sub__(self, a):
        return _meep.volume___sub__(self, a)

    def __isub__(self, a):
        return _meep.volume___isub__(self, a)

    def __eq__(self, a):
        return _meep.volume___eq__(self, a)

    def __ne__(self, a):
        return _meep.volume___ne__(self, a)

    def round_float(self):
        return _meep.volume_round_float(self)

    def intersects(self, a):
        return _meep.volume_intersects(self, a)

    def __contains__(self, a):
        return _meep.volume___contains__(self, a)

    def get_min_corner(self):
        return _meep.volume_get_min_corner(self)

    def get_max_corner(self):
        return _meep.volume_get_max_corner(self)

    def normal_direction(self):
        return _meep.volume_normal_direction(self)

    def __repr__(self):
        return _meep.volume___repr__(self)
    __swig_destroy__ = _meep.delete_volume

# Register volume in _meep:
_meep.volume_swigregister(volume)


def volcyl(rsize, zsize, a):
    return _meep.volcyl(rsize, zsize, a)

def volone(zsize, a):
    return _meep.volone(zsize, a)

def vol1d(zsize, a):
    return _meep.vol1d(zsize, a)

def voltwo(xsize, ysize, a):
    return _meep.voltwo(xsize, ysize, a)

def vol2d(xsize, ysize, a):
    return _meep.vol2d(xsize, ysize, a)

def vol3d(xsize, ysize, zsize, a):
    return _meep.vol3d(xsize, ysize, zsize, a)
class grid_volume(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self):
        _meep.grid_volume_swiginit(self, _meep.new_grid_volume())

    def subvolume(self, _is, ie):
        return _meep.grid_volume_subvolume(self, _is, ie)

    def init_subvolume(self, _is, ie):
        return _meep.grid_volume_init_subvolume(self, _is, ie)
    dim = property(_meep.grid_volume_dim_get, _meep.grid_volume_dim_set)
    a = property(_meep.grid_volume_a_get, _meep.grid_volume_a_set)
    inva = property(_meep.grid_volume_inva_get, _meep.grid_volume_inva_set)

    def print_grid_volume(self):
        return _meep.grid_volume_print_grid_volume(self)

    def stride(self, d):
        return _meep.grid_volume_stride(self, d)

    def num_direction(self, d):
        return _meep.grid_volume_num_direction(self, d)

    def yucky_num(self, arg2):
        return _meep.grid_volume_yucky_num(self, arg2)

    def yucky_direction(self, arg2):
        return _meep.grid_volume_yucky_direction(self, arg2)

    def set_num_direction(self, d, value):
        return _meep.grid_volume_set_num_direction(self, d, value)

    def nr(self):
        return _meep.grid_volume_nr(self)

    def nx(self):
        return _meep.grid_volume_nx(self)

    def ny(self):
        return _meep.grid_volume_ny(self)

    def nz(self):
        return _meep.grid_volume_nz(self)

    def has_field(self, c):
        return _meep.grid_volume_has_field(self, c)

    def has_boundary(self, arg2, arg3):
        return _meep.grid_volume_has_boundary(self, arg2, arg3)

    def dr(self):
        return _meep.grid_volume_dr(self)

    def dx(self):
        return _meep.grid_volume_dx(self)

    def dy(self):
        return _meep.grid_volume_dy(self)

    def dz(self):
        return _meep.grid_volume_dz(self)

    def ntot(self):
        return _meep.grid_volume_ntot(self)

    def nowned_min(self):
        return _meep.grid_volume_nowned_min(self)

    def nowned(self, c):
        return _meep.grid_volume_nowned(self, c)

    def __getitem__(self, p):
        return _meep.grid_volume___getitem__(self, p)

    def index(self, arg2, arg3):
        return _meep.grid_volume_index(self, arg2, arg3)

    def round_vec(self, arg2):
        return _meep.grid_volume_round_vec(self, arg2)

    def interpolate(self, *args):
        return _meep.grid_volume_interpolate(self, *args)

    def dV(self, *args):
        return _meep.grid_volume_dV(self, *args)

    def intersect_with(self, vol_in, intersection=None, others=None, num_others=None):
        return _meep.grid_volume_intersect_with(self, vol_in, intersection, others, num_others)

    def rmin(self):
        return _meep.grid_volume_rmin(self)

    def rmax(self):
        return _meep.grid_volume_rmax(self)

    def xmin(self):
        return _meep.grid_volume_xmin(self)

    def xmax(self):
        return _meep.grid_volume_xmax(self)

    def ymin(self):
        return _meep.grid_volume_ymin(self)

    def ymax(self):
        return _meep.grid_volume_ymax(self)

    def zmin(self):
        return _meep.grid_volume_zmin(self)

    def zmax(self):
        return _meep.grid_volume_zmax(self)

    def center(self):
        return _meep.grid_volume_center(self)

    def icenter(self):
        return _meep.grid_volume_icenter(self)

    def loc(self, arg2, index):
        return _meep.grid_volume_loc(self, arg2, index)

    def loc_at_resolution(self, index, res):
        return _meep.grid_volume_loc_at_resolution(self, index, res)

    def ntot_at_resolution(self, res):
        return _meep.grid_volume_ntot_at_resolution(self, res)

    def iloc(self, arg2, index):
        return _meep.grid_volume_iloc(self, arg2, index)

    def surface_area(self):
        return _meep.grid_volume_surface_area(self)

    def yee_index(self, c):
        return _meep.grid_volume_yee_index(self, c)

    def yee_shift(self, arg2):
        return _meep.grid_volume_yee_shift(self, arg2)

    def eps_component(self):
        return _meep.grid_volume_eps_component(self)

    def yee2cent_offsets(self, c, offset1, offset2):
        return _meep.grid_volume_yee2cent_offsets(self, c, offset1, offset2)

    def cent2yee_offsets(self, c, offset1, offset2):
        return _meep.grid_volume_cent2yee_offsets(self, c, offset1, offset2)

    def boundary_location(self, arg2, arg3):
        return _meep.grid_volume_boundary_location(self, arg2, arg3)

    def big_corner(self):
        return _meep.grid_volume_big_corner(self)

    def little_corner(self):
        return _meep.grid_volume_little_corner(self)

    def corner(self, b):
        return _meep.grid_volume_corner(self, b)

    def contains(self, *args):
        return _meep.grid_volume_contains(self, *args)

    def little_owned_corner0(self, c):
        return _meep.grid_volume_little_owned_corner0(self, c)

    def little_owned_corner(self, c):
        return _meep.grid_volume_little_owned_corner(self, c)

    def owns(self, arg2):
        return _meep.grid_volume_owns(self, arg2)

    def surroundings(self):
        return _meep.grid_volume_surroundings(self)

    def interior(self):
        return _meep.grid_volume_interior(self)

    def get_boundary_icorners(self, c, ib, cs, ce):
        return _meep.grid_volume_get_boundary_icorners(self, c, ib, cs, ce)

    def split(self, num, which):
        return _meep.grid_volume_split(self, num, which)

    def split_by_effort(self, num, which, Ngv=0, v=None, effort=None):
        return _meep.grid_volume_split_by_effort(self, num, which, Ngv, v, effort)

    def split_into_n(self, n):
        return _meep.grid_volume_split_into_n(self, n)

    def split_at_fraction(self, want_high, numer, bestd=-1, bestlen=1):
        return _meep.grid_volume_split_at_fraction(self, want_high, numer, bestd, bestlen)

    def get_cost(self):
        return _meep.grid_volume_get_cost(self)

    def halve(self, d):
        return _meep.grid_volume_halve(self, d)

    def pad_self(self, d):
        return _meep.grid_volume_pad_self(self, d)

    def pad(self, *args):
        return _meep.grid_volume_pad(self, *args)

    def iyee_shift(self, c):
        return _meep.grid_volume_iyee_shift(self, c)

    def get_origin(self):
        return _meep.grid_volume_get_origin(self)

    def shift_origin(self, *args):
        return _meep.grid_volume_shift_origin(self, *args)

    def set_origin(self, *args):
        return _meep.grid_volume_set_origin(self, *args)

    def center_origin(self):
        return _meep.grid_volume_center_origin(self)

    def origin_in_direction(self, d):
        return _meep.grid_volume_origin_in_direction(self, d)

    def iorigin_in_direction(self, d):
        return _meep.grid_volume_iorigin_in_direction(self, d)

    def origin_r(self):
        return _meep.grid_volume_origin_r(self)

    def origin_x(self):
        return _meep.grid_volume_origin_x(self)

    def origin_y(self):
        return _meep.grid_volume_origin_y(self)

    def origin_z(self):
        return _meep.grid_volume_origin_z(self)

    def __repr__(self):
        return _meep.grid_volume___repr__(self)
    __swig_destroy__ = _meep.delete_grid_volume

# Register grid_volume in _meep:
_meep.grid_volume_swigregister(grid_volume)


def identity():
    return _meep.identity()

def rotate4(arg1, arg2):
    return _meep.rotate4(arg1, arg2)

def rotate2(arg1, arg2):
    return _meep.rotate2(arg1, arg2)

def mirror(arg1, arg2):
    return _meep.mirror(arg1, arg2)

def r_to_minus_r_symmetry(m):
    return _meep.r_to_minus_r_symmetry(m)
class symmetry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.symmetry_swiginit(self, _meep.new_symmetry(*args))
    __swig_destroy__ = _meep.delete_symmetry

    def transform_unshifted(self, arg2, n):
        return _meep.symmetry_transform_unshifted(self, arg2, n)

    def transform(self, *args):
        return _meep.symmetry_transform(self, *args)

    def phase_shift(self, *args):
        return _meep.symmetry_phase_shift(self, *args)

    def multiplicity(self):
        return _meep.symmetry_multiplicity(self)

    def is_primitive(self, arg2):
        return _meep.symmetry_is_primitive(self, arg2)

    def symmetry_reduce(self, gl):
        return _meep.symmetry_symmetry_reduce(self, gl)

    def __add__(self, arg2):
        return _meep.symmetry___add__(self, arg2)

    def __mul__(self, arg2):
        return _meep.symmetry___mul__(self, arg2)

    def __sub__(self, b):
        return _meep.symmetry___sub__(self, b)

    def __neg__(self):
        return _meep.symmetry___neg__(self)

    def symmetry_assign(self, arg2):
        return _meep.symmetry_symmetry_assign(self, arg2)

    def __eq__(self, arg2):
        return _meep.symmetry___eq__(self, arg2)

    def __ne__(self, S):
        return _meep.symmetry___ne__(self, S)

# Register symmetry in _meep:
_meep.symmetry_swigregister(symmetry)

class volume_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_volume_list

    def __init__(self, *args):
        _meep.volume_list_swiginit(self, _meep.new_volume_list(*args))
    v = property(_meep.volume_list_v_get, _meep.volume_list_v_set)
    c = property(_meep.volume_list_c_get, _meep.volume_list_c_set)
    weight = property(_meep.volume_list_weight_get, _meep.volume_list_weight_set)
    next = property(_meep.volume_list_next_get, _meep.volume_list_next_set)

# Register volume_list in _meep:
_meep.volume_list_swigregister(volume_list)

MEEP_SINGLE = _meep.MEEP_SINGLE
MEEP_MIN_OUTPUT_TIME = _meep.MEEP_MIN_OUTPUT_TIME

def matrix_invert(Vinv, V):
    return _meep.matrix_invert(Vinv, V)

def linspace(freq_min, freq_max, Nfreq):
    return _meep.linspace(freq_min, freq_max, Nfreq)

def pml_quadratic_profile(arg1, arg2):
    return _meep.pml_quadratic_profile(arg1, arg2)
class susceptibility(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.susceptibility_swiginit(self, _meep.new_susceptibility(*args))

    def clone(self):
        return _meep.susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_susceptibility

    def get_id(self):
        return _meep.susceptibility_get_id(self)

    def __eq__(self, s):
        return _meep.susceptibility___eq__(self, s)

    def chi1(self, freq, sigma=1):
        return _meep.susceptibility_chi1(self, freq, sigma)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def needs_P(self, c, cmp, W):
        return _meep.susceptibility_needs_P(self, c, cmp, W)

    def needs_W_notowned(self, c, W):
        return _meep.susceptibility_needs_W_notowned(self, c, W)

    def needs_W_prev(self):
        return _meep.susceptibility_needs_W_prev(self)

    def new_internal_data(self, W, gv):
        return _meep.susceptibility_new_internal_data(self, W, gv)

    def delete_internal_data(self, data):
        return _meep.susceptibility_delete_internal_data(self, data)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.susceptibility_copy_internal_data(self, data)

    def num_internal_notowned_needed(self, c, P_internal_data):
        return _meep.susceptibility_num_internal_notowned_needed(self, c, P_internal_data)

    def internal_notowned_ptr(self, inotowned, c, n, P_internal_data):
        return _meep.susceptibility_internal_notowned_ptr(self, inotowned, c, n, P_internal_data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.susceptibility_get_num_params(self)

    def set_id(self, new_id):
        return _meep.susceptibility_set_id(self, new_id)
    next = property(_meep.susceptibility_next_get, _meep.susceptibility_next_set)
    ntot = property(_meep.susceptibility_ntot_get, _meep.susceptibility_ntot_set)
    sigma = property(_meep.susceptibility_sigma_get, _meep.susceptibility_sigma_set)
    trivial_sigma = property(_meep.susceptibility_trivial_sigma_get, _meep.susceptibility_trivial_sigma_set)

# Register susceptibility in _meep:
_meep.susceptibility_swigregister(susceptibility)
pi = cvar.pi
nan = cvar.nan

class lorentzian_susceptibility(susceptibility):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, omega_0, gamma, no_omega_0_denominator=False):
        _meep.lorentzian_susceptibility_swiginit(self, _meep.new_lorentzian_susceptibility(omega_0, gamma, no_omega_0_denominator))

    def clone(self):
        return _meep.lorentzian_susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_lorentzian_susceptibility

    def chi1(self, freq, sigma=1):
        return _meep.lorentzian_susceptibility_chi1(self, freq, sigma)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.lorentzian_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.lorentzian_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def new_internal_data(self, W, gv):
        return _meep.lorentzian_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.lorentzian_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.lorentzian_susceptibility_copy_internal_data(self, data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.lorentzian_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.lorentzian_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.lorentzian_susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.lorentzian_susceptibility_get_num_params(self)

# Register lorentzian_susceptibility in _meep:
_meep.lorentzian_susceptibility_swigregister(lorentzian_susceptibility)

class noisy_lorentzian_susceptibility(lorentzian_susceptibility):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, noise_amp, omega_0, gamma, no_omega_0_denominator=False):
        _meep.noisy_lorentzian_susceptibility_swiginit(self, _meep.new_noisy_lorentzian_susceptibility(noise_amp, omega_0, gamma, no_omega_0_denominator))

    def clone(self):
        return _meep.noisy_lorentzian_susceptibility_clone(self)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.noisy_lorentzian_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.noisy_lorentzian_susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.noisy_lorentzian_susceptibility_get_num_params(self)
    __swig_destroy__ = _meep.delete_noisy_lorentzian_susceptibility

# Register noisy_lorentzian_susceptibility in _meep:
_meep.noisy_lorentzian_susceptibility_swigregister(noisy_lorentzian_susceptibility)

GYROTROPIC_LORENTZIAN = _meep.GYROTROPIC_LORENTZIAN
GYROTROPIC_DRUDE = _meep.GYROTROPIC_DRUDE
GYROTROPIC_SATURATED = _meep.GYROTROPIC_SATURATED
class gyrotropic_susceptibility(susceptibility):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.gyrotropic_susceptibility_swiginit(self, _meep.new_gyrotropic_susceptibility(*args))

    def clone(self):
        return _meep.gyrotropic_susceptibility_clone(self)

    def new_internal_data(self, W, gv):
        return _meep.gyrotropic_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.gyrotropic_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.gyrotropic_susceptibility_copy_internal_data(self, data)

    def needs_P(self, c, cmp, W):
        return _meep.gyrotropic_susceptibility_needs_P(self, c, cmp, W)

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.gyrotropic_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.gyrotropic_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.gyrotropic_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.gyrotropic_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def dump_params(self, h5f, start):
        return _meep.gyrotropic_susceptibility_dump_params(self, h5f, start)

    def get_num_params(self):
        return _meep.gyrotropic_susceptibility_get_num_params(self)

    def needs_W_notowned(self, c, W):
        return _meep.gyrotropic_susceptibility_needs_W_notowned(self, c, W)
    __swig_destroy__ = _meep.delete_gyrotropic_susceptibility

# Register gyrotropic_susceptibility in _meep:
_meep.gyrotropic_susceptibility_swigregister(gyrotropic_susceptibility)

class multilevel_susceptibility(susceptibility):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.multilevel_susceptibility_swiginit(self, _meep.new_multilevel_susceptibility(*args))

    def clone(self):
        return _meep.multilevel_susceptibility_clone(self)
    __swig_destroy__ = _meep.delete_multilevel_susceptibility

    def update_P(self, W, W_prev, dt, gv, P_internal_data):
        return _meep.multilevel_susceptibility_update_P(self, W, W_prev, dt, gv, P_internal_data)

    def subtract_P(self, ft, f_minus_p, P_internal_data):
        return _meep.multilevel_susceptibility_subtract_P(self, ft, f_minus_p, P_internal_data)

    def new_internal_data(self, W, gv):
        return _meep.multilevel_susceptibility_new_internal_data(self, W, gv)

    def init_internal_data(self, W, dt, gv, data):
        return _meep.multilevel_susceptibility_init_internal_data(self, W, dt, gv, data)

    def copy_internal_data(self, data):
        return _meep.multilevel_susceptibility_copy_internal_data(self, data)

    def delete_internal_data(self, data):
        return _meep.multilevel_susceptibility_delete_internal_data(self, data)

    def num_cinternal_notowned_needed(self, c, P_internal_data):
        return _meep.multilevel_susceptibility_num_cinternal_notowned_needed(self, c, P_internal_data)

    def cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data):
        return _meep.multilevel_susceptibility_cinternal_notowned_ptr(self, inotowned, c, cmp, n, P_internal_data)

    def needs_W_notowned(self, c, W):
        return _meep.multilevel_susceptibility_needs_W_notowned(self, c, W)

    def needs_W_prev(self):
        return _meep.multilevel_susceptibility_needs_W_prev(self)

# Register multilevel_susceptibility in _meep:
_meep.multilevel_susceptibility_swigregister(multilevel_susceptibility)

class h5file(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    READONLY = _meep.h5file_READONLY
    READWRITE = _meep.h5file_READWRITE
    WRITE = _meep.h5file_WRITE

    def __init__(self, *args):
        _meep.h5file_swiginit(self, _meep.new_h5file(*args))
    __swig_destroy__ = _meep.delete_h5file

    def ok(self):
        return _meep.h5file_ok(self)

    def read(self, *args):
        return _meep.h5file_read(self, *args)

    def write(self, *args):
        return _meep.h5file_write(self, *args)

    def create_data(self, dataname, rank, dims, append_data=False, single_precision=True):
        return _meep.h5file_create_data(self, dataname, rank, dims, append_data, single_precision)

    def extend_data(self, dataname, rank, dims):
        return _meep.h5file_extend_data(self, dataname, rank, dims)

    def create_or_extend_data(self, dataname, rank, dims, append_data, single_precision):
        return _meep.h5file_create_or_extend_data(self, dataname, rank, dims, append_data, single_precision)

    def write_chunk(self, *args):
        return _meep.h5file_write_chunk(self, *args)

    def done_writing_chunks(self):
        return _meep.h5file_done_writing_chunks(self)

    def read_size(self, dataname, rank, dims, maxrank):
        return _meep.h5file_read_size(self, dataname, rank, dims, maxrank)

    def read_chunk(self, *args):
        return _meep.h5file_read_chunk(self, *args)

    def remove(self):
        return _meep.h5file_remove(self)

    def remove_data(self, dataname):
        return _meep.h5file_remove_data(self, dataname)

    def file_name(self):
        return _meep.h5file_file_name(self)

    def prevent_deadlock(self):
        return _meep.h5file_prevent_deadlock(self)

    def dataset_exists(self, name):
        return _meep.h5file_dataset_exists(self, name)
    extending = property(_meep.h5file_extending_get, _meep.h5file_extending_set)

    def get_extending(self, dataname):
        return _meep.h5file_get_extending(self, dataname)

# Register h5file in _meep:
_meep.h5file_swigregister(h5file)

DEFAULT_SUBPIXEL_TOL = _meep.DEFAULT_SUBPIXEL_TOL
DEFAULT_SUBPIXEL_MAXEVAL = _meep.DEFAULT_SUBPIXEL_MAXEVAL
class material_function(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _meep.material_function_swiginit(self, _meep.new_material_function())
    __swig_destroy__ = _meep.delete_material_function

    def set_volume(self, v):
        return _meep.material_function_set_volume(self, v)

    def unset_volume(self):
        return _meep.material_function_unset_volume(self)

    def chi1p1(self, ft, r):
        return _meep.material_function_chi1p1(self, ft, r)

    def eps(self, r):
        return _meep.material_function_eps(self, r)

    def has_mu(self):
        return _meep.material_function_has_mu(self)

    def mu(self, r):
        return _meep.material_function_mu(self, r)

    def has_conductivity(self, c):
        return _meep.material_function_has_conductivity(self, c)

    def conductivity(self, c, r):
        return _meep.material_function_conductivity(self, c, r)

    def normal_vector(self, ft, v):
        return _meep.material_function_normal_vector(self, ft, v)

    def eff_chi1inv_row(self, c, chi1inv_row, v, tol=1e-4, maxeval=100000):
        return _meep.material_function_eff_chi1inv_row(self, c, chi1inv_row, v, tol, maxeval)

    def sigma_row(self, c, sigrow, r):
        return _meep.material_function_sigma_row(self, c, sigrow, r)

    def has_chi3(self, c):
        return _meep.material_function_has_chi3(self, c)

    def chi3(self, c, r):
        return _meep.material_function_chi3(self, c, r)

    def has_chi2(self, c):
        return _meep.material_function_has_chi2(self, c)

    def chi2(self, c, r):
        return _meep.material_function_chi2(self, c, r)

# Register material_function in _meep:
_meep.material_function_swigregister(material_function)

class simple_material_function(material_function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, func):
        _meep.simple_material_function_swiginit(self, _meep.new_simple_material_function(func))
    __swig_destroy__ = _meep.delete_simple_material_function

    def chi1p1(self, ft, r):
        return _meep.simple_material_function_chi1p1(self, ft, r)

    def eps(self, r):
        return _meep.simple_material_function_eps(self, r)

    def mu(self, r):
        return _meep.simple_material_function_mu(self, r)

    def conductivity(self, c, r):
        return _meep.simple_material_function_conductivity(self, c, r)

    def sigma_row(self, c, sigrow, r):
        return _meep.simple_material_function_sigma_row(self, c, sigrow, r)

    def chi3(self, c, r):
        return _meep.simple_material_function_chi3(self, c, r)

    def chi2(self, c, r):
        return _meep.simple_material_function_chi2(self, c, r)

# Register simple_material_function in _meep:
_meep.simple_material_function_swigregister(simple_material_function)

class structure_chunk(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    a = property(_meep.structure_chunk_a_get, _meep.structure_chunk_a_set)
    Courant = property(_meep.structure_chunk_Courant_get, _meep.structure_chunk_Courant_set)
    dt = property(_meep.structure_chunk_dt_get, _meep.structure_chunk_dt_set)
    chi3 = property(_meep.structure_chunk_chi3_get, _meep.structure_chunk_chi3_set)
    chi2 = property(_meep.structure_chunk_chi2_get, _meep.structure_chunk_chi2_set)
    chi1inv = property(_meep.structure_chunk_chi1inv_get, _meep.structure_chunk_chi1inv_set)
    trivial_chi1inv = property(_meep.structure_chunk_trivial_chi1inv_get, _meep.structure_chunk_trivial_chi1inv_set)
    conductivity = property(_meep.structure_chunk_conductivity_get, _meep.structure_chunk_conductivity_set)
    condinv = property(_meep.structure_chunk_condinv_get, _meep.structure_chunk_condinv_set)
    condinv_stale = property(_meep.structure_chunk_condinv_stale_get, _meep.structure_chunk_condinv_stale_set)
    sig = property(_meep.structure_chunk_sig_get, _meep.structure_chunk_sig_set)
    kap = property(_meep.structure_chunk_kap_get, _meep.structure_chunk_kap_set)
    siginv = property(_meep.structure_chunk_siginv_get, _meep.structure_chunk_siginv_set)
    sigsize = property(_meep.structure_chunk_sigsize_get, _meep.structure_chunk_sigsize_set)
    gv = property(_meep.structure_chunk_gv_get, _meep.structure_chunk_gv_set)
    v = property(_meep.structure_chunk_v_get, _meep.structure_chunk_v_set)
    chiP = property(_meep.structure_chunk_chiP_get, _meep.structure_chunk_chiP_set)
    cost = property(_meep.structure_chunk_cost_get, _meep.structure_chunk_cost_set)
    refcount = property(_meep.structure_chunk_refcount_get, _meep.structure_chunk_refcount_set)
    __swig_destroy__ = _meep.delete_structure_chunk

    def __init__(self, *args):
        _meep.structure_chunk_swiginit(self, _meep.new_structure_chunk(*args))

    def set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval):
        return _meep.structure_chunk_set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval)

    def has_chi(self, c, d):
        return _meep.structure_chunk_has_chi(self, c, d)

    def has_chisigma(self, c, d):
        return _meep.structure_chunk_has_chisigma(self, c, d)

    def has_chi1inv(self, c, d):
        return _meep.structure_chunk_has_chi1inv(self, c, d)

    def set_conductivity(self, c, eps):
        return _meep.structure_chunk_set_conductivity(self, c, eps)

    def update_condinv(self):
        return _meep.structure_chunk_update_condinv(self)

    def set_chi3(self, c, eps):
        return _meep.structure_chunk_set_chi3(self, c, eps)

    def set_chi2(self, c, eps):
        return _meep.structure_chunk_set_chi2(self, c, eps)

    def use_pml(self, arg2, dx, boundary_loc, Rasymptotic, mean_stretch, pml_profile, pml_profile_data, pml_profile_integral, pml_profile_integral_u):
        return _meep.structure_chunk_use_pml(self, arg2, dx, boundary_loc, Rasymptotic, mean_stretch, pml_profile, pml_profile_data, pml_profile_integral, pml_profile_integral_u)

    def add_susceptibility(self, sigma, ft, sus):
        return _meep.structure_chunk_add_susceptibility(self, sigma, ft, sus)

    def mix_with(self, arg2, arg3):
        return _meep.structure_chunk_mix_with(self, arg2, arg3)

    def n_proc(self):
        return _meep.structure_chunk_n_proc(self)

    def is_mine(self):
        return _meep.structure_chunk_is_mine(self)

    def remove_susceptibilities(self):
        return _meep.structure_chunk_remove_susceptibilities(self)

    def get_chi1inv_at_pt(self, arg2, arg3, idx, frequency=0):
        return _meep.structure_chunk_get_chi1inv_at_pt(self, arg2, arg3, idx, frequency)

    def get_chi1inv(self, arg2, arg3, iloc, frequency=0):
        return _meep.structure_chunk_get_chi1inv(self, arg2, arg3, iloc, frequency)

    def get_inveps(self, c, d, iloc, frequency=0):
        return _meep.structure_chunk_get_inveps(self, c, d, iloc, frequency)

    def max_eps(self):
        return _meep.structure_chunk_max_eps(self)

# Register structure_chunk in _meep:
_meep.structure_chunk_swigregister(structure_chunk)

class boundary_region(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NOTHING_SPECIAL = _meep.boundary_region_NOTHING_SPECIAL
    PML = _meep.boundary_region_PML

    def __init__(self, *args):
        _meep.boundary_region_swiginit(self, _meep.new_boundary_region(*args))
    __swig_destroy__ = _meep.delete_boundary_region

    def boundary_region_assign(self, r):
        return _meep.boundary_region_boundary_region_assign(self, r)

    def __add__(self, r0):
        return _meep.boundary_region___add__(self, r0)

    def __mul__(self, strength_mult):
        return _meep.boundary_region___mul__(self, strength_mult)

    def br_apply(self, *args):
        return _meep.boundary_region_br_apply(self, *args)

    def check_ok(self, gv):
        return _meep.boundary_region_check_ok(self, gv)

# Register boundary_region in _meep:
_meep.boundary_region_swigregister(boundary_region)


def pml(*args):
    return _meep.pml(*args)
class structure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    chunks = property(_meep.structure_chunks_get, _meep.structure_chunks_set)
    num_chunks = property(_meep.structure_num_chunks_get, _meep.structure_num_chunks_set)
    shared_chunks = property(_meep.structure_shared_chunks_get, _meep.structure_shared_chunks_set)
    gv = property(_meep.structure_gv_get, _meep.structure_gv_set)
    user_volume = property(_meep.structure_user_volume_get, _meep.structure_user_volume_set)
    a = property(_meep.structure_a_get, _meep.structure_a_set)
    Courant = property(_meep.structure_Courant_get, _meep.structure_Courant_set)
    dt = property(_meep.structure_dt_get, _meep.structure_dt_set)
    v = property(_meep.structure_v_get, _meep.structure_v_set)
    S = property(_meep.structure_S_get, _meep.structure_S_set)
    outdir = property(_meep.structure_outdir_get, _meep.structure_outdir_set)
    effort_volumes = property(_meep.structure_effort_volumes_get, _meep.structure_effort_volumes_set)
    effort = property(_meep.structure_effort_get, _meep.structure_effort_set)
    num_effort_volumes = property(_meep.structure_num_effort_volumes_get, _meep.structure_num_effort_volumes_set)
    __swig_destroy__ = _meep.delete_structure

    def __init__(self, *args):
        _meep.structure_swiginit(self, _meep.new_structure(*args))

    def set_materials(self, mat, use_anisotropic_averaging=True, tol=1e-4, maxeval=100000):
        return _meep.structure_set_materials(self, mat, use_anisotropic_averaging, tol, maxeval)

    def set_chi1inv(self, c, eps, use_anisotropic_averaging=True, tol=1e-4, maxeval=100000):
        return _meep.structure_set_chi1inv(self, c, eps, use_anisotropic_averaging, tol, maxeval)

    def has_chi(self, c, d):
        return _meep.structure_has_chi(self, c, d)

    def set_epsilon(self, *args):
        return _meep.structure_set_epsilon(self, *args)

    def set_mu(self, *args):
        return _meep.structure_set_mu(self, *args)

    def set_conductivity(self, *args):
        return _meep.structure_set_conductivity(self, *args)

    def set_chi3(self, *args):
        return _meep.structure_set_chi3(self, *args)

    def set_chi2(self, *args):
        return _meep.structure_set_chi2(self, *args)

    def add_susceptibility(self, *args):
        return _meep.structure_add_susceptibility(self, *args)

    def remove_susceptibilities(self):
        return _meep.structure_remove_susceptibilities(self)

    def set_output_directory(self, name):
        return _meep.structure_set_output_directory(self, name)

    def mix_with(self, arg2, arg3):
        return _meep.structure_mix_with(self, arg2, arg3)

    def equal_layout(self, arg2):
        return _meep.structure_equal_layout(self, arg2)

    def print_layout(self):
        return _meep.structure_print_layout(self)

    def get_chunk_volumes(self):
        return _meep.structure_get_chunk_volumes(self)

    def get_chunk_owners(self):
        return _meep.structure_get_chunk_owners(self)

    def dump(self, filename):
        return _meep.structure_dump(self, filename)

    def dump_chunk_layout(self, filename):
        return _meep.structure_dump_chunk_layout(self, filename)

    def load(self, filename):
        return _meep.structure_load(self, filename)

    def load_chunk_layout(self, *args):
        return _meep.structure_load_chunk_layout(self, *args)

    def get_chi1inv(self, *args):
        return _meep.structure_get_chi1inv(self, *args)

    def get_inveps(self, *args):
        return _meep.structure_get_inveps(self, *args)

    def get_eps(self, loc, frequency=0):
        return _meep.structure_get_eps(self, loc, frequency)

    def get_mu(self, loc, frequency=0):
        return _meep.structure_get_mu(self, loc, frequency)

    def max_eps(self):
        return _meep.structure_max_eps(self)

    def estimated_cost(self, *args):
        return _meep.structure_estimated_cost(self, *args)

# Register structure in _meep:
_meep.structure_swigregister(structure)


def choose_chunkdivision(gv, v, num_chunks, s):
    return _meep.choose_chunkdivision(gv, v, num_chunks, s)
class src_time(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_integrated = property(_meep.src_time_is_integrated_get, _meep.src_time_is_integrated_set)
    __swig_destroy__ = _meep.delete_src_time

    def __init__(self, *args):
        _meep.src_time_swiginit(self, _meep.new_src_time(*args))

    def update(self, time, dt):
        return _meep.src_time_update(self, time, dt)

    def current(self, *args):
        return _meep.src_time_current(self, *args)

    def last_time_max(self, *args):
        return _meep.src_time_last_time_max(self, *args)

    def add_to(self, others, added):
        return _meep.src_time_add_to(self, others, added)
    next = property(_meep.src_time_next_get, _meep.src_time_next_set)

    def dipole(self, *args):
        return _meep.src_time_dipole(self, *args)

    def last_time(self):
        return _meep.src_time_last_time(self)

    def clone(self):
        return _meep.src_time_clone(self)

    def is_equal(self, t):
        return _meep.src_time_is_equal(self, t)

    def frequency(self):
        return _meep.src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.src_time_set_frequency(self, f)

# Register src_time in _meep:
_meep.src_time_swigregister(src_time)


def src_times_equal(t1, t2):
    return _meep.src_times_equal(t1, t2)
class gaussian_src_time(src_time):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.gaussian_src_time_swiginit(self, _meep.new_gaussian_src_time(*args))
    __swig_destroy__ = _meep.delete_gaussian_src_time

    def dipole(self, time):
        return _meep.gaussian_src_time_dipole(self, time)

    def last_time(self):
        return _meep.gaussian_src_time_last_time(self)

    def clone(self):
        return _meep.gaussian_src_time_clone(self)

    def is_equal(self, t):
        return _meep.gaussian_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.gaussian_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.gaussian_src_time_set_frequency(self, f)

    def fourier_transform(self, f):
        return _meep.gaussian_src_time_fourier_transform(self, f)

# Register gaussian_src_time in _meep:
_meep.gaussian_src_time_swigregister(gaussian_src_time)

class continuous_src_time(src_time):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.continuous_src_time_swiginit(self, _meep.new_continuous_src_time(*args))
    __swig_destroy__ = _meep.delete_continuous_src_time

    def dipole(self, time):
        return _meep.continuous_src_time_dipole(self, time)

    def last_time(self):
        return _meep.continuous_src_time_last_time(self)

    def clone(self):
        return _meep.continuous_src_time_clone(self)

    def is_equal(self, t):
        return _meep.continuous_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.continuous_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.continuous_src_time_set_frequency(self, f)

# Register continuous_src_time in _meep:
_meep.continuous_src_time_swigregister(continuous_src_time)

class custom_src_time(src_time):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.custom_src_time_swiginit(self, _meep.new_custom_src_time(*args))
    __swig_destroy__ = _meep.delete_custom_src_time

    def current(self, time, dt):
        return _meep.custom_src_time_current(self, time, dt)

    def dipole(self, time):
        return _meep.custom_src_time_dipole(self, time)

    def last_time(self):
        return _meep.custom_src_time_last_time(self)

    def clone(self):
        return _meep.custom_src_time_clone(self)

    def is_equal(self, t):
        return _meep.custom_src_time_is_equal(self, t)

    def frequency(self):
        return _meep.custom_src_time_frequency(self)

    def set_frequency(self, f):
        return _meep.custom_src_time_set_frequency(self, f)

# Register custom_src_time in _meep:
_meep.custom_src_time_swigregister(custom_src_time)

class monitor_point(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _meep.monitor_point_swiginit(self, _meep.new_monitor_point())
    __swig_destroy__ = _meep.delete_monitor_point
    loc = property(_meep.monitor_point_loc_get, _meep.monitor_point_loc_set)
    t = property(_meep.monitor_point_t_get, _meep.monitor_point_t_set)
    f = property(_meep.monitor_point_f_get, _meep.monitor_point_f_set)
    next = property(_meep.monitor_point_next_get, _meep.monitor_point_next_set)

    def get_component(self, arg2):
        return _meep.monitor_point_get_component(self, arg2)

    def poynting_in_direction(self, *args):
        return _meep.monitor_point_poynting_in_direction(self, *args)

    def fourier_transform(self, w, a, f, numout, fmin=0.0, fmax=0.0, maxbands=100):
        return _meep.monitor_point_fourier_transform(self, w, a, f, numout, fmin, fmax, maxbands)

    def harminv(self, w, a, f, numout, fmin, fmax, maxbands):
        return _meep.monitor_point_harminv(self, w, a, f, numout, fmin, fmax, maxbands)

# Register monitor_point in _meep:
_meep.monitor_point_swigregister(monitor_point)

class dft_chunk(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fc_, is_, ie_, s0_, s1_, e0_, e1_, dV0_, dV1_, c_, use_centered_grid, phase_factor, shift_, S_, sn_, data_):
        _meep.dft_chunk_swiginit(self, _meep.new_dft_chunk(fc_, is_, ie_, s0_, s1_, e0_, e1_, dV0_, dV1_, c_, use_centered_grid, phase_factor, shift_, S_, sn_, data_))
    __swig_destroy__ = _meep.delete_dft_chunk

    def update_dft(self, time):
        return _meep.dft_chunk_update_dft(self, time)

    def scale_dft(self, scale):
        return _meep.dft_chunk_scale_dft(self, scale)

    def process_dft_component(self, rank, ds, min_corner, max_corner, num_freq, file, buffer, reim, field_array, mode1_data, mode2_data, ic_conjugate, retain_interp_weights, parent):
        return _meep.dft_chunk_process_dft_component(self, rank, ds, min_corner, max_corner, num_freq, file, buffer, reim, field_array, mode1_data, mode2_data, ic_conjugate, retain_interp_weights, parent)

    def __isub__(self, chunk):
        return _meep.dft_chunk___isub__(self, chunk)
    omega = property(_meep.dft_chunk_omega_get, _meep.dft_chunk_omega_set)
    c = property(_meep.dft_chunk_c_get, _meep.dft_chunk_c_set)
    N = property(_meep.dft_chunk_N_get, _meep.dft_chunk_N_set)
    dft = property(_meep.dft_chunk_dft_get, _meep.dft_chunk_dft_set)
    next_in_chunk = property(_meep.dft_chunk_next_in_chunk_get, _meep.dft_chunk_next_in_chunk_set)
    next_in_dft = property(_meep.dft_chunk_next_in_dft_get, _meep.dft_chunk_next_in_dft_set)
    stored_weight = property(_meep.dft_chunk_stored_weight_get, _meep.dft_chunk_stored_weight_set)
    include_dV_and_interp_weights = property(_meep.dft_chunk_include_dV_and_interp_weights_get, _meep.dft_chunk_include_dV_and_interp_weights_set)
    sqrt_dV_and_interp_weights = property(_meep.dft_chunk_sqrt_dV_and_interp_weights_get, _meep.dft_chunk_sqrt_dV_and_interp_weights_set)
    extra_weight = property(_meep.dft_chunk_extra_weight_get, _meep.dft_chunk_extra_weight_set)
    fc = property(_meep.dft_chunk_fc_get, _meep.dft_chunk_fc_set)
    _is = property(_meep.dft_chunk__is_get, _meep.dft_chunk__is_set)
    ie = property(_meep.dft_chunk_ie_get, _meep.dft_chunk_ie_set)
    s0 = property(_meep.dft_chunk_s0_get, _meep.dft_chunk_s0_set)
    s1 = property(_meep.dft_chunk_s1_get, _meep.dft_chunk_s1_set)
    e0 = property(_meep.dft_chunk_e0_get, _meep.dft_chunk_e0_set)
    e1 = property(_meep.dft_chunk_e1_get, _meep.dft_chunk_e1_set)
    dV0 = property(_meep.dft_chunk_dV0_get, _meep.dft_chunk_dV0_set)
    dV1 = property(_meep.dft_chunk_dV1_get, _meep.dft_chunk_dV1_set)
    empty_dim = property(_meep.dft_chunk_empty_dim_get, _meep.dft_chunk_empty_dim_set)
    scale = property(_meep.dft_chunk_scale_get, _meep.dft_chunk_scale_set)
    shift = property(_meep.dft_chunk_shift_get, _meep.dft_chunk_shift_set)
    S = property(_meep.dft_chunk_S_get, _meep.dft_chunk_S_set)
    sn = property(_meep.dft_chunk_sn_get, _meep.dft_chunk_sn_set)
    dft_phase = property(_meep.dft_chunk_dft_phase_get, _meep.dft_chunk_dft_phase_set)
    avg1 = property(_meep.dft_chunk_avg1_get, _meep.dft_chunk_avg1_set)
    avg2 = property(_meep.dft_chunk_avg2_get, _meep.dft_chunk_avg2_set)
    vc = property(_meep.dft_chunk_vc_get, _meep.dft_chunk_vc_set)

# Register dft_chunk in _meep:
_meep.dft_chunk_swigregister(dft_chunk)


def save_dft_hdf5(*args):
    return _meep.save_dft_hdf5(*args)

def load_dft_hdf5(*args):
    return _meep.load_dft_hdf5(*args)
class dft_flux(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.dft_flux_swiginit(self, _meep.new_dft_flux(*args))

    def flux(self):
        return _meep.dft_flux_flux(self)

    def __isub__(self, fl):
        return _meep.dft_flux___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_flux_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_flux_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_flux_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_flux_remove(self)
    freq = property(_meep.dft_flux_freq_get, _meep.dft_flux_freq_set)
    E = property(_meep.dft_flux_E_get, _meep.dft_flux_E_set)
    H = property(_meep.dft_flux_H_get, _meep.dft_flux_H_set)
    cE = property(_meep.dft_flux_cE_get, _meep.dft_flux_cE_set)
    cH = property(_meep.dft_flux_cH_get, _meep.dft_flux_cH_set)
    where = property(_meep.dft_flux_where_get, _meep.dft_flux_where_set)
    normal_direction = property(_meep.dft_flux_normal_direction_get, _meep.dft_flux_normal_direction_set)
    use_symmetry = property(_meep.dft_flux_use_symmetry_get, _meep.dft_flux_use_symmetry_set)
    __swig_destroy__ = _meep.delete_dft_flux

# Register dft_flux in _meep:
_meep.dft_flux_swigregister(dft_flux)

class dft_energy(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.dft_energy_swiginit(self, _meep.new_dft_energy(*args))

    def electric(self):
        return _meep.dft_energy_electric(self)

    def magnetic(self):
        return _meep.dft_energy_magnetic(self)

    def total(self):
        return _meep.dft_energy_total(self)

    def __isub__(self, fl):
        return _meep.dft_energy___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_energy_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_energy_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_energy_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_energy_remove(self)
    freq = property(_meep.dft_energy_freq_get, _meep.dft_energy_freq_set)
    E = property(_meep.dft_energy_E_get, _meep.dft_energy_E_set)
    H = property(_meep.dft_energy_H_get, _meep.dft_energy_H_set)
    D = property(_meep.dft_energy_D_get, _meep.dft_energy_D_set)
    B = property(_meep.dft_energy_B_get, _meep.dft_energy_B_set)
    where = property(_meep.dft_energy_where_get, _meep.dft_energy_where_set)
    __swig_destroy__ = _meep.delete_dft_energy

# Register dft_energy in _meep:
_meep.dft_energy_swigregister(dft_energy)

class dft_force(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.dft_force_swiginit(self, _meep.new_dft_force(*args))

    def force(self):
        return _meep.dft_force_force(self)

    def __isub__(self, fl):
        return _meep.dft_force___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_force_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_force_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_force_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_force_remove(self)
    freq = property(_meep.dft_force_freq_get, _meep.dft_force_freq_set)
    offdiag1 = property(_meep.dft_force_offdiag1_get, _meep.dft_force_offdiag1_set)
    offdiag2 = property(_meep.dft_force_offdiag2_get, _meep.dft_force_offdiag2_set)
    diag = property(_meep.dft_force_diag_get, _meep.dft_force_diag_set)
    where = property(_meep.dft_force_where_get, _meep.dft_force_where_set)
    __swig_destroy__ = _meep.delete_dft_force

# Register dft_force in _meep:
_meep.dft_force_swigregister(dft_force)

class sourcedata(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    near_fd_comp = property(_meep.sourcedata_near_fd_comp_get, _meep.sourcedata_near_fd_comp_set)
    idx_arr = property(_meep.sourcedata_idx_arr_get, _meep.sourcedata_idx_arr_set)
    fc_idx = property(_meep.sourcedata_fc_idx_get, _meep.sourcedata_fc_idx_set)
    amp_arr = property(_meep.sourcedata_amp_arr_get, _meep.sourcedata_amp_arr_set)

    def __init__(self):
        _meep.sourcedata_swiginit(self, _meep.new_sourcedata())
    __swig_destroy__ = _meep.delete_sourcedata

# Register sourcedata in _meep:
_meep.sourcedata_swigregister(sourcedata)

class dft_near2far(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.dft_near2far_swiginit(self, _meep.new_dft_near2far(*args))

    def farfield(self, x):
        return _meep.dft_near2far_farfield(self, x)

    def farfield_lowlevel(self, F, x):
        return _meep.dft_near2far_farfield_lowlevel(self, F, x)

    def get_farfields_array(self, where, rank, dims, N, resolution):
        return _meep.dft_near2far_get_farfields_array(self, where, rank, dims, N, resolution)

    def save_farfields(self, fname, prefix, where, resolution):
        return _meep.dft_near2far_save_farfields(self, fname, prefix, where, resolution)

    def flux(self, df, where, resolution):
        return _meep.dft_near2far_flux(self, df, where, resolution)

    def __isub__(self, fl):
        return _meep.dft_near2far___isub__(self, fl)

    def save_hdf5(self, *args):
        return _meep.dft_near2far_save_hdf5(self, *args)

    def load_hdf5(self, *args):
        return _meep.dft_near2far_load_hdf5(self, *args)

    def scale_dfts(self, scale):
        return _meep.dft_near2far_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_near2far_remove(self)
    freq = property(_meep.dft_near2far_freq_get, _meep.dft_near2far_freq_set)
    F = property(_meep.dft_near2far_F_get, _meep.dft_near2far_F_set)
    eps = property(_meep.dft_near2far_eps_get, _meep.dft_near2far_eps_set)
    mu = property(_meep.dft_near2far_mu_get, _meep.dft_near2far_mu_set)
    where = property(_meep.dft_near2far_where_get, _meep.dft_near2far_where_set)
    periodic_d = property(_meep.dft_near2far_periodic_d_get, _meep.dft_near2far_periodic_d_set)
    periodic_n = property(_meep.dft_near2far_periodic_n_get, _meep.dft_near2far_periodic_n_set)
    periodic_k = property(_meep.dft_near2far_periodic_k_get, _meep.dft_near2far_periodic_k_set)
    period = property(_meep.dft_near2far_period_get, _meep.dft_near2far_period_set)

    def near_sourcedata(self, x_0, farpt_list, nfar_pts, dJ):
        return _meep.dft_near2far_near_sourcedata(self, x_0, farpt_list, nfar_pts, dJ)
    __swig_destroy__ = _meep.delete_dft_near2far

# Register dft_near2far in _meep:
_meep.dft_near2far_swigregister(dft_near2far)

class dft_ldos(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _meep.delete_dft_ldos

    def update(self, f):
        return _meep.dft_ldos_update(self, f)

    def ldos(self):
        return _meep.dft_ldos_ldos(self)

    def F(self):
        return _meep.dft_ldos_F(self)

    def J(self):
        return _meep.dft_ldos_J(self)
    freq = property(_meep.dft_ldos_freq_get, _meep.dft_ldos_freq_set)

# Register dft_ldos in _meep:
_meep.dft_ldos_swigregister(dft_ldos)

def _dft_ldos(*args):
    val = _meep.new__dft_ldos(*args)
    return val

class dft_fields(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _meep.dft_fields_swiginit(self, _meep.new_dft_fields(*args))

    def scale_dfts(self, scale):
        return _meep.dft_fields_scale_dfts(self, scale)

    def remove(self):
        return _meep.dft_fields_remove(self)
    freq = property(_meep.dft_fields_freq_get, _meep.dft_fields_freq_set)
    chunks = property(_meep.dft_fields_chunks_get, _meep.dft_fields_chunks_set)
    where = property(_meep.dft_fields_where_get, _meep.dft_fields_where_set)
    __swig_destroy__ = _meep.delete_dft_fields

# Register dft_fields in _meep:
_meep.dft_fields_swigregister(dft_fields)

Incoming = _meep.Incoming
Outgoing = _meep.Outgoing
CONNECT_PHASE = _meep.CONNECT_PHASE
CONNECT_NEGATE = _meep.CONNECT_NEGATE
CONNECT_COPY = _meep.CONNECT_COPY
class polarization_state(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_meep.polarization_state_data_get, _meep.polarization_state_data_set)
    s = property(_meep.polarization_state_s_get, _meep.polarization_state_s_set)
    next = property(_meep.polarization_state_next_get, _meep.polarization_state_next_set)

    def __init__(self):
        _meep.polarization_state_swiginit(self, _meep.new_polarization_state())
    __swig_destroy__ = _meep.delete_polarization_state

# Register polarization_state in _meep:
_meep.polarization_state_swigregister(polarization_state)

class fields_chunk(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    f = property(_meep.fields_chunk_f_get, _meep.fields_chunk_f_set)
    f_u = property(_meep.fields_chunk_f_u_get, _meep.fields_chunk_f_u_set)
    f_w = property(_meep.fields_chunk_f_w_get, _meep.fields_chunk_f_w_set)
    f_cond = property(_meep.fields_chunk_f_cond_get, _meep.fields_chunk_f_cond_set)
    f_backup = property(_meep.fields_chunk_f_backup_get, _meep.fields_chunk_f_backup_set)
    f_u_backup = property(_meep.fields_chunk_f_u_backup_get, _meep.fields_chunk_f_u_backup_set)
    f_w_backup = property(_meep.fields_chunk_f_w_backup_get, _meep.fields_chunk_f_w_backup_set)
    f_cond_backup = property(_meep.fields_chunk_f_cond_backup_get, _meep.fields_chunk_f_cond_backup_set)
    f_w_prev = property(_meep.fields_chunk_f_w_prev_get, _meep.fields_chunk_f_w_prev_set)
    f_minus_p = property(_meep.fields_chunk_f_minus_p_get, _meep.fields_chunk_f_minus_p_set)
    f_rderiv_int = property(_meep.fields_chunk_f_rderiv_int_get, _meep.fields_chunk_f_rderiv_int_set)
    dft_chunks = property(_meep.fields_chunk_dft_chunks_get, _meep.fields_chunk_dft_chunks_set)
    zeroes = property(_meep.fields_chunk_zeroes_get, _meep.fields_chunk_zeroes_set)
    num_zeroes = property(_meep.fields_chunk_num_zeroes_get, _meep.fields_chunk_num_zeroes_set)
    connections = property(_meep.fields_chunk_connections_get)
    num_connections = property(_meep.fields_chunk_num_connections_get)
    connection_phases = property(_meep.fields_chunk_connection_phases_get, _meep.fields_chunk_connection_phases_set)
    npol = property(_meep.fields_chunk_npol_get, _meep.fields_chunk_npol_set)
    pol = property(_meep.fields_chunk_pol_get, _meep.fields_chunk_pol_set)
    a = property(_meep.fields_chunk_a_get, _meep.fields_chunk_a_set)
    Courant = property(_meep.fields_chunk_Courant_get, _meep.fields_chunk_Courant_set)
    dt = property(_meep.fields_chunk_dt_get, _meep.fields_chunk_dt_set)
    gv = property(_meep.fields_chunk_gv_get, _meep.fields_chunk_gv_set)
    v = property(_meep.fields_chunk_v_get, _meep.fields_chunk_v_set)
    m = property(_meep.fields_chunk_m_get, _meep.fields_chunk_m_set)
    zero_fields_near_cylorigin = property(_meep.fields_chunk_zero_fields_near_cylorigin_get, _meep.fields_chunk_zero_fields_near_cylorigin_set)
    beta = property(_meep.fields_chunk_beta_get, _meep.fields_chunk_beta_set)
    is_real = property(_meep.fields_chunk_is_real_get, _meep.fields_chunk_is_real_set)
    sources = property(_meep.fields_chunk_sources_get, _meep.fields_chunk_sources_set)
    new_s = property(_meep.fields_chunk_new_s_get, _meep.fields_chunk_new_s_set)
    s = property(_meep.fields_chunk_s_get, _meep.fields_chunk_s_set)
    outdir = property(_meep.fields_chunk_outdir_get, _meep.fields_chunk_outdir_set)
    chunk_idx = property(_meep.fields_chunk_chunk_idx_get, _meep.fields_chunk_chunk_idx_set)

    def __init__(self, *args):
        _meep.fields_chunk_swiginit(self, _meep.new_fields_chunk(*args))
    __swig_destroy__ = _meep.delete_fields_chunk

    def use_real_fields(self):
        return _meep.fields_chunk_use_real_fields(self)

    def have_component(self, c, is_complex=False):
        return _meep.fields_chunk_have_component(self, c, is_complex)

    def last_source_time(self):
        return _meep.fields_chunk_last_source_time(self)

    def get_field(self, arg2, arg3):
        return _meep.fields_chunk_get_field(self, arg2, arg3)

    def get_chi1inv(self, arg2, arg3, iloc, frequency=0):
        return _meep.fields_chunk_get_chi1inv(self, arg2, arg3, iloc, frequency)

    def backup_component(self, c):
        return _meep.fields_chunk_backup_component(self, c)

    def average_with_backup(self, c):
        return _meep.fields_chunk_average_with_backup(self, c)

    def restore_component(self, c):
        return _meep.fields_chunk_restore_component(self, c)

    def set_output_directory(self, name):
        return _meep.fields_chunk_set_output_directory(self, name)

    def count_volume(self, arg2):
        return _meep.fields_chunk_count_volume(self, arg2)

    def n_proc(self):
        return _meep.fields_chunk_n_proc(self)

    def is_mine(self):
        return _meep.fields_chunk_is_mine(self)

    def zero_metal(self, arg2):
        return _meep.fields_chunk_zero_metal(self, arg2)

    def needs_W_notowned(self, c):
        return _meep.fields_chunk_needs_W_notowned(self, c)

    def remove_sources(self):
        return _meep.fields_chunk_remove_sources(self)

    def remove_susceptibilities(self, shared_chunks):
        return _meep.fields_chunk_remove_susceptibilities(self, shared_chunks)

    def zero_fields(self):
        return _meep.fields_chunk_zero_fields(self)

    def needs_W_prev(self, c):
        return _meep.fields_chunk_needs_W_prev(self, c)

    def update_eh(self, ft, skip_w_components=False):
        return _meep.fields_chunk_update_eh(self, ft, skip_w_components)

    def alloc_f(self, c):
        return _meep.fields_chunk_alloc_f(self, c)

    def figure_out_step_plan(self):
        return _meep.fields_chunk_figure_out_step_plan(self)

    def set_solve_cw_omega(self, omega):
        return _meep.fields_chunk_set_solve_cw_omega(self, omega)

    def unset_solve_cw_omega(self):
        return _meep.fields_chunk_unset_solve_cw_omega(self)

# Register fields_chunk in _meep:
_meep.fields_chunk_swigregister(fields_chunk)

Periodic = _meep.Periodic
Metallic = _meep.Metallic
Magnetic = _meep.Magnetic
Meep_None = _meep.Meep_None
Connecting = _meep.Connecting
Stepping = _meep.Stepping
Boundaries = _meep.Boundaries
MpiTime = _meep.MpiTime
FieldOutput = _meep.FieldOutput
FourierTransforming = _meep.FourierTransforming
MPBTime = _meep.MPBTime
GetFarfieldsTime = _meep.GetFarfieldsTime
Other = _meep.Other

def derived_component_func(c, gv, nfields, cs):
    return _meep.derived_component_func(c, gv, nfields, cs)
class chunkloop_field_components(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, fc, cgrid, shift_phase, S, sn, num_fields, components):
        _meep.chunkloop_field_components_swiginit(self, _meep.new_chunkloop_field_components(fc, cgrid, shift_phase, S, sn, num_fields, components))

    def update_values(self, idx):
        return _meep.chunkloop_field_components_update_values(self, idx)
    values = property(_meep.chunkloop_field_components_values_get, _meep.chunkloop_field_components_values_set)
    __swig_destroy__ = _meep.delete_chunkloop_field_components

# Register chunkloop_field_components in _meep:
_meep.chunkloop_field_components_swigregister(chunkloop_field_components)

class diffractedplanewave(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, g, axis, s, p):
        _meep.diffractedplanewave_swiginit(self, _meep.new_diffractedplanewave(g, axis, s, p))

    def get_g(self):
        return _meep.diffractedplanewave_get_g(self)

    def get_axis(self):
        return _meep.diffractedplanewave_get_axis(self)

    def get_s(self):
        return _meep.diffractedplanewave_get_s(self)

    def get_p(self):
        return _meep.diffractedplanewave_get_p(self)
    __swig_destroy__ = _meep.delete_diffractedplanewave

# Register diffractedplanewave in _meep:
_meep.diffractedplanewave_swigregister(diffractedplanewave)

class gaussianbeam(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, x0, kdir, w0, freq, eps, mu, E0):
        _meep.gaussianbeam_swiginit(self, _meep.new_gaussianbeam(x0, kdir, w0, freq, eps, mu, E0))

    def get_fields(self, EH, x):
        return _meep.gaussianbeam_get_fields(self, EH, x)

    def get_E0(self, n):
        return _meep.gaussianbeam_get_E0(self, n)
    __swig_destroy__ = _meep.delete_gaussianbeam

# Register gaussianbeam in _meep:
_meep.gaussianbeam_swigregister(gaussianbeam)

class fields(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_chunks = property(_meep.fields_num_chunks_get, _meep.fields_num_chunks_set)
    shared_chunks = property(_meep.fields_shared_chunks_get, _meep.fields_shared_chunks_set)
    chunks = property(_meep.fields_chunks_get, _meep.fields_chunks_set)
    sources = property(_meep.fields_sources_get, _meep.fields_sources_set)
    fluxes = property(_meep.fields_fluxes_get, _meep.fields_fluxes_set)
    S = property(_meep.fields_S_get, _meep.fields_S_set)
    comm_blocks = property(_meep.fields_comm_blocks_get, _meep.fields_comm_blocks_set)
    comm_sizes = property(_meep.fields_comm_sizes_get, _meep.fields_comm_sizes_set)

    def comm_size_tot(self, f, pair):
        return _meep.fields_comm_size_tot(self, f, pair)
    a = property(_meep.fields_a_get, _meep.fields_a_set)
    dt = property(_meep.fields_dt_get, _meep.fields_dt_set)
    gv = property(_meep.fields_gv_get, _meep.fields_gv_set)
    user_volume = property(_meep.fields_user_volume_get, _meep.fields_user_volume_set)
    v = property(_meep.fields_v_get, _meep.fields_v_set)
    m = property(_meep.fields_m_get, _meep.fields_m_set)
    beta = property(_meep.fields_beta_get, _meep.fields_beta_set)
    t = property(_meep.fields_t_get, _meep.fields_t_set)
    phasein_time = property(_meep.fields_phasein_time_get, _meep.fields_phasein_time_set)
    is_real = property(_meep.fields_is_real_get, _meep.fields_is_real_set)
    k = property(_meep.fields_k_get, _meep.fields_k_set)
    eikna = property(_meep.fields_eikna_get, _meep.fields_eikna_set)
    coskna = property(_meep.fields_coskna_get, _meep.fields_coskna_set)
    sinkna = property(_meep.fields_sinkna_get, _meep.fields_sinkna_set)
    boundaries = property(_meep.fields_boundaries_get, _meep.fields_boundaries_set)
    outdir = property(_meep.fields_outdir_get, _meep.fields_outdir_set)
    components_allocated = property(_meep.fields_components_allocated_get, _meep.fields_components_allocated_set)

    def __init__(self, *args):
        _meep.fields_swiginit(self, _meep.new_fields(*args))
    __swig_destroy__ = _meep.delete_fields

    def equal_layout(self, f):
        return _meep.fields_equal_layout(self, f)

    def use_real_fields(self):
        return _meep.fields_use_real_fields(self)

    def zero_fields(self):
        return _meep.fields_zero_fields(self)

    def remove_sources(self):
        return _meep.fields_remove_sources(self)

    def remove_susceptibilities(self):
        return _meep.fields_remove_susceptibilities(self)

    def remove_fluxes(self):
        return _meep.fields_remove_fluxes(self)

    def reset(self):
        return _meep.fields_reset(self)

    def time_spent_on(self, arg2):
        return _meep.fields_time_spent_on(self, arg2)

    def mean_time_spent_on(self, arg2):
        return _meep.fields_mean_time_spent_on(self, arg2)

    def print_times(self):
        return _meep.fields_print_times(self)

    def set_boundary(self, arg2, arg3, arg4):
        return _meep.fields_set_boundary(self, arg2, arg3, arg4)

    def use_bloch(self, *args):
        return _meep.fields_use_bloch(self, *args)

    def lattice_vector(self, arg2):
        return _meep.fields_lattice_vector(self, arg2)

    def update_eh(self, ft, skip_w_components=False):
        return _meep.fields_update_eh(self, ft, skip_w_components)

    def total_volume(self):
        return _meep.fields_total_volume(self)

    def output_hdf5(self, *args):
        return _meep.fields_output_hdf5(self, *args)

    def open_h5file(self, *args):
        return _meep.fields_open_h5file(self, *args)

    def h5file_name(self, name, prefix=None, timestamp=False):
        return _meep.fields_h5file_name(self, name, prefix, timestamp)

    def output_times(self, fname):
        return _meep.fields_output_times(self, fname)

    def get_array_slice_dimensions(self, *args):
        return _meep.fields_get_array_slice_dimensions(self, *args)

    def get_array_slice(self, *args):
        return _meep.fields_get_array_slice(self, *args)

    def get_complex_array_slice(self, *args):
        return _meep.fields_get_complex_array_slice(self, *args)

    def get_source_slice(self, where, source_slice_component, slice=None):
        return _meep.fields_get_source_slice(self, where, source_slice_component, slice)

    def do_get_array_slice(self, where, components, fun, rfun, fun_data, vslice, frequency=0, snap=False):
        return _meep.fields_do_get_array_slice(self, where, components, fun, rfun, fun_data, vslice, frequency, snap)

    def get_array_metadata(self, where):
        return _meep.fields_get_array_metadata(self, where)
    last_step_output_wall_time = property(_meep.fields_last_step_output_wall_time_get, _meep.fields_last_step_output_wall_time_set)
    last_step_output_t = property(_meep.fields_last_step_output_t_get, _meep.fields_last_step_output_t_set)

    def step(self):
        return _meep.fields_step(self)

    def round_time(self):
        return _meep.fields_round_time(self)

    def time(self):
        return _meep.fields_time(self)

    def solve_cw(self, *args):
        return _meep.fields_solve_cw(self, *args)

    def last_source_time(self):
        return _meep.fields_last_source_time(self)

    def add_point_source(self, *args):
        return _meep.fields_add_point_source(self, *args)

    def add_volume_source(self, *args):
        return _meep.fields_add_volume_source(self, *args)

    def require_component(self, c):
        return _meep.fields_require_component(self, c)

    def add_srcdata(self, cur_data, src, n, amp_arr):
        return _meep.fields_add_srcdata(self, cur_data, src, n, amp_arr)

    def get_eigenmode(self, frequency, d, where, eig_vol, band_num, kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom=None, user_mdata=None, dp=None):
        return _meep.fields_get_eigenmode(self, frequency, d, where, eig_vol, band_num, kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom, user_mdata, dp)

    def add_eigenmode_source(self, *args):
        return _meep.fields_add_eigenmode_source(self, *args)

    def get_eigenmode_coefficients(self, *args):
        return _meep.fields_get_eigenmode_coefficients(self, *args)

    def initialize_field(self, arg2, f):
        return _meep.fields_initialize_field(self, arg2, f)

    def initialize_with_nth_te(self, n):
        return _meep.fields_initialize_with_nth_te(self, n)

    def initialize_with_nth_tm(self, n):
        return _meep.fields_initialize_with_nth_tm(self, n)

    def initialize_with_n_te(self, ntot):
        return _meep.fields_initialize_with_n_te(self, ntot)

    def initialize_with_n_tm(self, ntot):
        return _meep.fields_initialize_with_n_tm(self, ntot)

    def phase_in_material(self, s, time):
        return _meep.fields_phase_in_material(self, s, time)

    def is_phasing(self):
        return _meep.fields_is_phasing(self)

    def loop_in_chunks(self, *args):
        return _meep.fields_loop_in_chunks(self, *args)

    def integrate(self, *args):
        return _meep.fields_integrate(self, *args)

    def integrate2(self, *args):
        return _meep.fields_integrate2(self, *args)

    def max_abs(self, *args):
        return _meep.fields_max_abs(self, *args)

    def add_dft_pt(self, *args):
        return _meep.fields_add_dft_pt(self, *args)

    def add_dft(self, *args):
        return _meep.fields_add_dft(self, *args)

    def update_dfts(self):
        return _meep.fields_update_dfts(self)

    def add_dft_flux(self, *args):
        return _meep.fields_add_dft_flux(self, *args)

    def add_dft_flux_box(self, *args):
        return _meep.fields_add_dft_flux_box(self, *args)

    def add_dft_flux_plane(self, *args):
        return _meep.fields_add_dft_flux_plane(self, *args)

    def add_mode_monitor(self, *args):
        return _meep.fields_add_mode_monitor(self, *args)

    def add_dft_fields(self, *args):
        return _meep.fields_add_dft_fields(self, *args)

    def process_dft_component(self, *args):
        return _meep.fields_process_dft_component(self, *args)

    def output_dft_components(self, chunklists, num_chunklists, dft_volume, HDF5FileName):
        return _meep.fields_output_dft_components(self, chunklists, num_chunklists, dft_volume, HDF5FileName)

    def output_dft(self, *args):
        return _meep.fields_output_dft(self, *args)

    def get_dft_array(self, *args):
        return _meep.fields_get_dft_array(self, *args)

    def get_overlap(self, mode1_data, mode2_data, flux, num_freq, overlaps):
        return _meep.fields_get_overlap(self, mode1_data, mode2_data, flux, num_freq, overlaps)

    def get_mode_flux_overlap(self, mode_data, flux, num_freq, overlaps):
        return _meep.fields_get_mode_flux_overlap(self, mode_data, flux, num_freq, overlaps)

    def get_mode_mode_overlap(self, mode1_data, mode2_data, flux, overlaps):
        return _meep.fields_get_mode_mode_overlap(self, mode1_data, mode2_data, flux, overlaps)

    def add_dft_energy(self, *args):
        return _meep.fields_add_dft_energy(self, *args)

    def add_dft_force(self, *args):
        return _meep.fields_add_dft_force(self, *args)

    def add_dft_near2far(self, *args):
        return _meep.fields_add_dft_near2far(self, *args)

    def get_inveps(self, c, d, loc, frequency=0):
        return _meep.fields_get_inveps(self, c, d, loc, frequency)

    def get_eps(self, loc, frequency=0):
        return _meep.fields_get_eps(self, loc, frequency)

    def get_mu(self, loc, frequency=0):
        return _meep.fields_get_mu(self, loc, frequency)

    def get_point(self, p, arg3):
        return _meep.fields_get_point(self, p, arg3)

    def get_new_point(self, arg2, p=None):
        return _meep.fields_get_new_point(self, arg2, p)

    def get_field_from_comp(self, *args):
        return _meep.fields_get_field_from_comp(self, *args)

    def synchronize_magnetic_fields(self):
        return _meep.fields_synchronize_magnetic_fields(self)

    def restore_magnetic_fields(self):
        return _meep.fields_restore_magnetic_fields(self)

    def energy_in_box(self, arg2):
        return _meep.fields_energy_in_box(self, arg2)

    def electric_energy_in_box(self, arg2):
        return _meep.fields_electric_energy_in_box(self, arg2)

    def magnetic_energy_in_box(self, arg2):
        return _meep.fields_magnetic_energy_in_box(self, arg2)

    def thermo_energy_in_box(self, arg2):
        return _meep.fields_thermo_energy_in_box(self, arg2)

    def total_energy(self):
        return _meep.fields_total_energy(self)

    def field_energy_in_box(self, *args):
        return _meep.fields_field_energy_in_box(self, *args)

    def field_energy(self):
        return _meep.fields_field_energy(self)

    def flux_in_box_wrongH(self, d, arg3):
        return _meep.fields_flux_in_box_wrongH(self, d, arg3)

    def flux_in_box(self, d, arg3):
        return _meep.fields_flux_in_box(self, d, arg3)

    def add_flux_vol(self, d, where):
        return _meep.fields_add_flux_vol(self, d, where)

    def add_flux_plane(self, *args):
        return _meep.fields_add_flux_plane(self, *args)

    def electric_energy_max_in_box(self, where):
        return _meep.fields_electric_energy_max_in_box(self, where)

    def modal_volume_in_box(self, where):
        return _meep.fields_modal_volume_in_box(self, where)

    def electric_sqr_weighted_integral(self, deps, where):
        return _meep.fields_electric_sqr_weighted_integral(self, deps, where)

    def electric_energy_weighted_integral(self, f, where):
        return _meep.fields_electric_energy_weighted_integral(self, f, where)

    def set_output_directory(self, name):
        return _meep.fields_set_output_directory(self, name)

    def count_volume(self, arg2):
        return _meep.fields_count_volume(self, arg2)

    def have_component(self, arg2):
        return _meep.fields_have_component(self, arg2)

    def max_eps(self):
        return _meep.fields_max_eps(self)

    def step_boundaries(self, arg2):
        return _meep.fields_step_boundaries(self, arg2)

    def nosize_direction(self, d):
        return _meep.fields_nosize_direction(self, d)

    def normal_direction(self, where):
        return _meep.fields_normal_direction(self, where)

    def casimir_stress_dct_integral(self, dforce, dsource, mx, my, mz, ft, where, is_bloch=False):
        return _meep.fields_casimir_stress_dct_integral(self, dforce, dsource, mx, my, mz, ft, where, is_bloch)

    def set_solve_cw_omega(self, omega):
        return _meep.fields_set_solve_cw_omega(self, omega)

    def unset_solve_cw_omega(self):
        return _meep.fields_unset_solve_cw_omega(self)

    def get_field(self, *args):
        return _meep.fields_get_field(self, *args)

    def get_chi1inv(self, *args):
        return _meep.fields_get_chi1inv(self, *args)

    def locate_component_point(self, arg2, arg3, arg4):
        return _meep.fields_locate_component_point(self, arg2, arg3, arg4)

    def am_now_working_on(self, arg2):
        return _meep.fields_am_now_working_on(self, arg2)

    def finished_working(self):
        return _meep.fields_finished_working(self)

    def reset_timers(self):
        return _meep.fields_reset_timers(self)

    def is_periodic(self, side, dir):
        return _meep.fields_is_periodic(self, side, dir)

# Register fields in _meep:
_meep.fields_swigregister(fields)

class flux_vol(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, f_, d_, where_):
        _meep.flux_vol_swiginit(self, _meep.new_flux_vol(f_, d_, where_))
    __swig_destroy__ = _meep.delete_flux_vol

    def update_half(self):
        return _meep.flux_vol_update_half(self)

    def update(self):
        return _meep.flux_vol_update(self)

    def flux(self):
        return _meep.flux_vol_flux(self)
    next = property(_meep.flux_vol_next_get, _meep.flux_vol_next_set)

# Register flux_vol in _meep:
_meep.flux_vol_swigregister(flux_vol)


def make_output_directory(*args):
    return _meep.make_output_directory(*args)

def trash_output_directory(dirname):
    return _meep.trash_output_directory(dirname)

def delete_directory(path):
    return _meep.delete_directory(path)

def create_output_file(dirname, fname):
    return _meep.create_output_file(dirname, fname)

def do_harminv(data, n, dt, fmin, fmax, maxbands, amps, freq_re, freq_im, errors=None, spectral_density=1.1, Q_thresh=50, rel_err_thresh=1e20, err_thresh=0.01, rel_amp_thresh=-1, amp_thresh=-1):
    return _meep.do_harminv(data, n, dt, fmin, fmax, maxbands, amps, freq_re, freq_im, errors, spectral_density, Q_thresh, rel_err_thresh, err_thresh, rel_amp_thresh, amp_thresh)

def make_casimir_gfunc(T, dt, sigma, ft, eps_func=None, Tfft=0):
    return _meep.make_casimir_gfunc(T, dt, sigma, ft, eps_func, Tfft)

def make_casimir_gfunc_kz(T, dt, sigma, ft):
    return _meep.make_casimir_gfunc_kz(T, dt, sigma, ft)

def set_random_seed(seed):
    return _meep.set_random_seed(seed)

def restore_random_seed():
    return _meep.restore_random_seed()

def uniform_random(a, b):
    return _meep.uniform_random(a, b)

def gaussian_random(mean, stddev):
    return _meep.gaussian_random(mean, stddev)

def random_int(a, b):
    return _meep.random_int(a, b)

def BesselJ(m, kr):
    return _meep.BesselJ(m, kr)

def green2d(EH, x, freq, eps, mu, x0, c0, f0):
    return _meep.green2d(EH, x, freq, eps, mu, x0, c0, f0)

def green3d(EH, x, freq, eps, mu, x0, c0, f0):
    return _meep.green3d(EH, x, freq, eps, mu, x0, c0, f0)

def destroy_eigenmode_data(vedata, destroy_mdata=True):
    return _meep.destroy_eigenmode_data(vedata, destroy_mdata)

def eigenmode_amplitude(vedata, p, c):
    return _meep.eigenmode_amplitude(vedata, p, c)

def get_group_velocity(vedata):
    return _meep.get_group_velocity(vedata)

def get_k(vedata):
    return _meep.get_k(vedata)

def linear_interpolate(rx, ry, rz, data, nx, ny, nz, stride):
    return _meep.linear_interpolate(rx, ry, rz, data, nx, ny, nz, stride)

def wall_time():
    return _meep.wall_time()
class initialize(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, argc, argv):
        _meep.initialize_swiginit(self, _meep.new_initialize(argc, argv))
    __swig_destroy__ = _meep.delete_initialize

    def elapsed_time(self):
        return _meep.initialize_elapsed_time(self)

# Register initialize in _meep:
_meep.initialize_swigregister(initialize)


def all_wait():
    return _meep.all_wait()

def count_processors():
    return _meep.count_processors()

def my_rank():
    return _meep.my_rank()

def am_really_master():
    return _meep.am_really_master()

def am_master():
    return _meep.am_master()

def with_mpi():
    return _meep.with_mpi()

def send(_from, to, data, size=1):
    return _meep.send(_from, to, data, size)

def broadcast(*args):
    return _meep.broadcast(*args)

def max_to_master(arg1):
    return _meep.max_to_master(arg1)

def max_to_all(*args):
    return _meep.max_to_all(*args)

def partial_sum_to_all(*args):
    return _meep.partial_sum_to_all(*args)

def sum_to_all(*args):
    return _meep.sum_to_all(*args)

def sum_to_master(*args):
    return _meep.sum_to_master(*args)

def or_to_all(*args):
    return _meep.or_to_all(*args)

def bw_or_to_all(_in, out, size):
    return _meep.bw_or_to_all(_in, out, size)

def and_to_all(*args):
    return _meep.and_to_all(*args)

def master_printf(*args):
    return _meep.master_printf(*args)

def master_printf_stderr(*args):
    return _meep.master_printf_stderr(*args)

def debug_printf(*args):
    return _meep.debug_printf(*args)

def master_fprintf(*args):
    return _meep.master_fprintf(*args)

def master_fopen(name, mode):
    return _meep.master_fopen(name, mode)

def master_fclose(f):
    return _meep.master_fclose(f)

def set_meep_printf_callback(func):
    return _meep.set_meep_printf_callback(func)

def set_meep_printf_stderr_callback(func):
    return _meep.set_meep_printf_stderr_callback(func)

def begin_critical_section(tag):
    return _meep.begin_critical_section(tag)

def end_critical_section(tag):
    return _meep.end_critical_section(tag)

def divide_parallel_processes(numgroups):
    return _meep.divide_parallel_processes(numgroups)

def begin_global_communications():
    return _meep.begin_global_communications()

def end_global_communications():
    return _meep.end_global_communications()

def end_divide_parallel():
    return _meep.end_divide_parallel()

def my_global_rank():
    return _meep.my_global_rank()
CYLINDRICAL = _meep.CYLINDRICAL
X_DIR = _meep.X_DIR
Y_DIR = _meep.Y_DIR
Z_DIR = _meep.Z_DIR
R_DIR = _meep.R_DIR
PHI_DIR = _meep.PHI_DIR
ALL_SIDES = _meep.ALL_SIDES
ALL_DIRECTIONS = _meep.ALL_DIRECTIONS
ENORMOUS = _meep.ENORMOUS
TINY = _meep.TINY
class dft_data(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_freqs = property(_meep.dft_data_num_freqs_get, _meep.dft_data_num_freqs_set)
    num_components = property(_meep.dft_data_num_components_get, _meep.dft_data_num_components_set)
    vols = property(_meep.dft_data_vols_get, _meep.dft_data_vols_set)

    def __init__(self, freqs, components, volumes):
        _meep.dft_data_swiginit(self, _meep.new_dft_data(freqs, components, volumes))
    __swig_destroy__ = _meep.delete_dft_data

# Register dft_data in _meep:
_meep.dft_data_swigregister(dft_data)

class fragment_stats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tol = property(_meep.fragment_stats_tol_get, _meep.fragment_stats_tol_set)
    maxeval = property(_meep.fragment_stats_maxeval_get, _meep.fragment_stats_maxeval_set)
    resolution = property(_meep.fragment_stats_resolution_get, _meep.fragment_stats_resolution_set)
    dims = property(_meep.fragment_stats_dims_get, _meep.fragment_stats_dims_set)
    geom = property(_meep.fragment_stats_geom_get, _meep.fragment_stats_geom_set)
    dft_data_list = property(_meep.fragment_stats_dft_data_list_get, _meep.fragment_stats_dft_data_list_set)
    pml_1d_vols = property(_meep.fragment_stats_pml_1d_vols_get, _meep.fragment_stats_pml_1d_vols_set)
    pml_2d_vols = property(_meep.fragment_stats_pml_2d_vols_get, _meep.fragment_stats_pml_2d_vols_set)
    pml_3d_vols = property(_meep.fragment_stats_pml_3d_vols_get, _meep.fragment_stats_pml_3d_vols_set)
    absorber_vols = property(_meep.fragment_stats_absorber_vols_get, _meep.fragment_stats_absorber_vols_set)
    extra_materials = property(_meep.fragment_stats_extra_materials_get, _meep.fragment_stats_extra_materials_set)
    split_chunks_evenly = property(_meep.fragment_stats_split_chunks_evenly_get, _meep.fragment_stats_split_chunks_evenly_set)
    eps_averaging = property(_meep.fragment_stats_eps_averaging_get, _meep.fragment_stats_eps_averaging_set)

    @staticmethod
    def has_non_medium_material():
        return _meep.fragment_stats_has_non_medium_material()

    @staticmethod
    def init_libctl(default_mat, ensure_per, gv, cell_size, cell_center, geom_list):
        return _meep.fragment_stats_init_libctl(default_mat, ensure_per, gv, cell_size, cell_center, geom_list)
    num_anisotropic_eps_pixels = property(_meep.fragment_stats_num_anisotropic_eps_pixels_get, _meep.fragment_stats_num_anisotropic_eps_pixels_set)
    num_anisotropic_mu_pixels = property(_meep.fragment_stats_num_anisotropic_mu_pixels_get, _meep.fragment_stats_num_anisotropic_mu_pixels_set)
    num_nonlinear_pixels = property(_meep.fragment_stats_num_nonlinear_pixels_get, _meep.fragment_stats_num_nonlinear_pixels_set)
    num_susceptibility_pixels = property(_meep.fragment_stats_num_susceptibility_pixels_get, _meep.fragment_stats_num_susceptibility_pixels_set)
    num_nonzero_conductivity_pixels = property(_meep.fragment_stats_num_nonzero_conductivity_pixels_get, _meep.fragment_stats_num_nonzero_conductivity_pixels_set)
    num_1d_pml_pixels = property(_meep.fragment_stats_num_1d_pml_pixels_get, _meep.fragment_stats_num_1d_pml_pixels_set)
    num_2d_pml_pixels = property(_meep.fragment_stats_num_2d_pml_pixels_get, _meep.fragment_stats_num_2d_pml_pixels_set)
    num_3d_pml_pixels = property(_meep.fragment_stats_num_3d_pml_pixels_get, _meep.fragment_stats_num_3d_pml_pixels_set)
    num_dft_pixels = property(_meep.fragment_stats_num_dft_pixels_get, _meep.fragment_stats_num_dft_pixels_set)
    num_pixels_in_box = property(_meep.fragment_stats_num_pixels_in_box_get, _meep.fragment_stats_num_pixels_in_box_set)
    box = property(_meep.fragment_stats_box_get, _meep.fragment_stats_box_set)

    def __init__(self, *args):
        _meep.fragment_stats_swiginit(self, _meep.new_fragment_stats(*args))

    def compute(self):
        return _meep.fragment_stats_compute(self)

    def cost(self):
        return _meep.fragment_stats_cost(self)

    def print_stats(self):
        return _meep.fragment_stats_print_stats(self)
    __swig_destroy__ = _meep.delete_fragment_stats

# Register fragment_stats in _meep:
_meep.fragment_stats_swigregister(fragment_stats)

def fragment_stats_has_non_medium_material():
    return _meep.fragment_stats_has_non_medium_material()

def fragment_stats_init_libctl(default_mat, ensure_per, gv, cell_size, cell_center, geom_list):
    return _meep.fragment_stats_init_libctl(default_mat, ensure_per, gv, cell_size, cell_center, geom_list)


def compute_fragment_stats(geom, gv, cell_size, cell_center, default_mat, dft_data_list, pml_1d_vols, pml_2d_vols, pml_3d_vols, absorber_vols, extra_materials, tol, maxeval, ensure_per, eps_averaging):
    return _meep.compute_fragment_stats(geom, gv, cell_size, cell_center, default_mat, dft_data_list, pml_1d_vols, pml_2d_vols, pml_3d_vols, absorber_vols, extra_materials, tol, maxeval, ensure_per, eps_averaging)
class absorber(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    thickness = property(_meep.absorber_thickness_get, _meep.absorber_thickness_set)
    direction = property(_meep.absorber_direction_get, _meep.absorber_direction_set)
    side = property(_meep.absorber_side_get, _meep.absorber_side_set)
    R_asymptotic = property(_meep.absorber_R_asymptotic_get, _meep.absorber_R_asymptotic_set)
    mean_stretch = property(_meep.absorber_mean_stretch_get, _meep.absorber_mean_stretch_set)
    pml_profile = property(_meep.absorber_pml_profile_get, _meep.absorber_pml_profile_set)
    pml_profile_data = property(_meep.absorber_pml_profile_data_get, _meep.absorber_pml_profile_data_set)

    def __init__(self):
        _meep.absorber_swiginit(self, _meep.new_absorber())
    __swig_destroy__ = _meep.delete_absorber

# Register absorber in _meep:
_meep.absorber_swigregister(absorber)


def create_absorber_list():
    return _meep.create_absorber_list()

def destroy_absorber_list(alist):
    return _meep.destroy_absorber_list(alist)

def add_absorbing_layer(*args):
    return _meep.add_absorbing_layer(*args)

def make_vector3(x=0.0, y=0.0, z=0.0):
    return _meep.make_vector3(x, y, z)

def set_dimensions(dims):
    return _meep.set_dimensions(dims)

def set_materials_from_geometry(*args):
    return _meep.set_materials_from_geometry(*args)

def make_dielectric(epsilon):
    return _meep.make_dielectric(epsilon)

def make_user_material(user_func, user_data, do_averaging):
    return _meep.make_user_material(user_func, user_data, do_averaging)

def make_file_material(eps_input_file):
    return _meep.make_file_material(eps_input_file)

def make_material_grid():
    return _meep.make_material_grid()

def vec_to_vector3(pt):
    return _meep.vec_to_vector3(pt)

def vector3_to_vec(v3):
    return _meep.vector3_to_vec(v3)

def epsilon_material_grid(md, u):
    return _meep.epsilon_material_grid(md, u)

def epsilon_file_material(md, p):
    return _meep.epsilon_file_material(md, p)

def is_material_grid(*args):
    return _meep.is_material_grid(*args)

def check_offdiag(m):
    return _meep.check_offdiag(m)

def gv2box(v):
    return _meep.gv2box(v)

def update_design_parameters(matgrid, design_parameters):
    return _meep.update_design_parameters(matgrid, design_parameters)

def matgrid_val(p, tp, oi, md):
    return _meep.matgrid_val(p, tp, oi, md)

def material_grid_val(p, md):
    return _meep.material_grid_val(p, md)

def calculate_tree(v, g):
    return _meep.calculate_tree(v, g)

def get_material_tensor(mm, freq, tensor):
    return _meep.get_material_tensor(mm, freq, tensor)

def get_material_gradient(u, fields_a, fields_f, freq, md, field_dir, du=1.0e-3):
    return _meep.get_material_gradient(u, fields_a, fields_f, freq, md, field_dir, du)

def add_interpolate_weights(rx, ry, rz, data, nx, ny, nz, stride, scaleby, udata, ukind, uval):
    return _meep.add_interpolate_weights(rx, ry, rz, data, nx, ny, nz, stride, scaleby, udata, ukind, uval)

def material_grids_addgradient_point(v, fields_a, fields_f, field_dir, p, scalegrad, freq, geometry_tree):
    return _meep.material_grids_addgradient_point(v, fields_a, fields_f, field_dir, p, scalegrad, freq, geometry_tree)

def material_grids_addgradient(v, ng, fields_a, fields_f, frequencies, nf, scalegrad, where, geometry_tree, f):
    return _meep.material_grids_addgradient(v, ng, fields_a, fields_f, frequencies, nf, scalegrad, where, geometry_tree, f)

def with_libGDSII():
    return _meep.with_libGDSII()

def set_geometry_from_GDSII(*args):
    return _meep.set_geometry_from_GDSII(*args)

def get_GDSII_prisms(material, GDSIIFile, Layer=-1, zmin=0.0, zmax=0.0):
    return _meep.get_GDSII_prisms(material, GDSIIFile, Layer, zmin, zmax)

def get_GDSII_prism(*args):
    return _meep.get_GDSII_prism(*args)

def get_GDSII_volume(*args):
    return _meep.get_GDSII_volume(*args)

def get_GDSII_layers(GDSIIFile):
    return _meep.get_GDSII_layers(GDSIIFile)
class near_src_data(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.near_src_data_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.near_src_data___nonzero__(self)

    def __bool__(self):
        return _meep.near_src_data___bool__(self)

    def __len__(self):
        return _meep.near_src_data___len__(self)

    def __getslice__(self, i, j):
        return _meep.near_src_data___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.near_src_data___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.near_src_data___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.near_src_data___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.near_src_data___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.near_src_data___setitem__(self, *args)

    def pop(self):
        return _meep.near_src_data_pop(self)

    def append(self, x):
        return _meep.near_src_data_append(self, x)

    def empty(self):
        return _meep.near_src_data_empty(self)

    def size(self):
        return _meep.near_src_data_size(self)

    def swap(self, v):
        return _meep.near_src_data_swap(self, v)

    def begin(self):
        return _meep.near_src_data_begin(self)

    def end(self):
        return _meep.near_src_data_end(self)

    def rbegin(self):
        return _meep.near_src_data_rbegin(self)

    def rend(self):
        return _meep.near_src_data_rend(self)

    def clear(self):
        return _meep.near_src_data_clear(self)

    def get_allocator(self):
        return _meep.near_src_data_get_allocator(self)

    def pop_back(self):
        return _meep.near_src_data_pop_back(self)

    def erase(self, *args):
        return _meep.near_src_data_erase(self, *args)

    def __init__(self, *args):
        _meep.near_src_data_swiginit(self, _meep.new_near_src_data(*args))

    def push_back(self, x):
        return _meep.near_src_data_push_back(self, x)

    def front(self):
        return _meep.near_src_data_front(self)

    def back(self):
        return _meep.near_src_data_back(self)

    def assign(self, n, x):
        return _meep.near_src_data_assign(self, n, x)

    def resize(self, *args):
        return _meep.near_src_data_resize(self, *args)

    def insert(self, *args):
        return _meep.near_src_data_insert(self, *args)

    def reserve(self, n):
        return _meep.near_src_data_reserve(self, n)

    def capacity(self):
        return _meep.near_src_data_capacity(self)
    __swig_destroy__ = _meep.delete_near_src_data

# Register near_src_data in _meep:
_meep.near_src_data_swigregister(near_src_data)

class ComplexVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _meep.ComplexVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _meep.ComplexVector___nonzero__(self)

    def __bool__(self):
        return _meep.ComplexVector___bool__(self)

    def __len__(self):
        return _meep.ComplexVector___len__(self)

    def __getslice__(self, i, j):
        return _meep.ComplexVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _meep.ComplexVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _meep.ComplexVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _meep.ComplexVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _meep.ComplexVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _meep.ComplexVector___setitem__(self, *args)

    def pop(self):
        return _meep.ComplexVector_pop(self)

    def append(self, x):
        return _meep.ComplexVector_append(self, x)

    def empty(self):
        return _meep.ComplexVector_empty(self)

    def size(self):
        return _meep.ComplexVector_size(self)

    def swap(self, v):
        return _meep.ComplexVector_swap(self, v)

    def begin(self):
        return _meep.ComplexVector_begin(self)

    def end(self):
        return _meep.ComplexVector_end(self)

    def rbegin(self):
        return _meep.ComplexVector_rbegin(self)

    def rend(self):
        return _meep.ComplexVector_rend(self)

    def clear(self):
        return _meep.ComplexVector_clear(self)

    def get_allocator(self):
        return _meep.ComplexVector_get_allocator(self)

    def pop_back(self):
        return _meep.ComplexVector_pop_back(self)

    def erase(self, *args):
        return _meep.ComplexVector_erase(self, *args)

    def __init__(self, *args):
        _meep.ComplexVector_swiginit(self, _meep.new_ComplexVector(*args))

    def push_back(self, x):
        return _meep.ComplexVector_push_back(self, x)

    def front(self):
        return _meep.ComplexVector_front(self)

    def back(self):
        return _meep.ComplexVector_back(self)

    def assign(self, n, x):
        return _meep.ComplexVector_assign(self, n, x)

    def resize(self, *args):
        return _meep.ComplexVector_resize(self, *args)

    def insert(self, *args):
        return _meep.ComplexVector_insert(self, *args)

    def reserve(self, n):
        return _meep.ComplexVector_reserve(self, n)

    def capacity(self):
        return _meep.ComplexVector_capacity(self)
    __swig_destroy__ = _meep.delete_ComplexVector

# Register ComplexVector in _meep:
_meep.ComplexVector_swigregister(ComplexVector)

class vector3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_meep.vector3_x_get, _meep.vector3_x_set)
    y = property(_meep.vector3_y_get, _meep.vector3_y_set)
    z = property(_meep.vector3_z_get, _meep.vector3_z_set)

    def __init__(self):
        _meep.vector3_swiginit(self, _meep.new_vector3())
    __swig_destroy__ = _meep.delete_vector3

# Register vector3 in _meep:
_meep.vector3_swigregister(vector3)

class geom_box(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    low = property(_meep.geom_box_low_get, _meep.geom_box_low_set)
    high = property(_meep.geom_box_high_get, _meep.geom_box_high_set)

    def __init__(self):
        _meep.geom_box_swiginit(self, _meep.new_geom_box())
    __swig_destroy__ = _meep.delete_geom_box

# Register geom_box in _meep:
_meep.geom_box_swigregister(geom_box)

class eigenmode_data(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    mdata = property(_meep.eigenmode_data_mdata_get, _meep.eigenmode_data_mdata_set)
    fft_data_H = property(_meep.eigenmode_data_fft_data_H_get, _meep.eigenmode_data_fft_data_H_set)
    fft_data_E = property(_meep.eigenmode_data_fft_data_E_get, _meep.eigenmode_data_fft_data_E_set)
    H = property(_meep.eigenmode_data_H_get, _meep.eigenmode_data_H_set)
    n = property(_meep.eigenmode_data_n_get, _meep.eigenmode_data_n_set)
    s = property(_meep.eigenmode_data_s_get, _meep.eigenmode_data_s_set)
    Gk = property(_meep.eigenmode_data_Gk_get, _meep.eigenmode_data_Gk_set)
    center = property(_meep.eigenmode_data_center_get, _meep.eigenmode_data_center_set)
    amp_func = property(_meep.eigenmode_data_amp_func_get, _meep.eigenmode_data_amp_func_set)
    band_num = property(_meep.eigenmode_data_band_num_get, _meep.eigenmode_data_band_num_set)
    frequency = property(_meep.eigenmode_data_frequency_get, _meep.eigenmode_data_frequency_set)
    group_velocity = property(_meep.eigenmode_data_group_velocity_get, _meep.eigenmode_data_group_velocity_set)
    __swig_destroy__ = _meep.delete_eigenmode_data

    def __init__(self):
        _meep.eigenmode_data_swiginit(self, _meep.new_eigenmode_data())

# Register eigenmode_data in _meep:
_meep.eigenmode_data_swigregister(eigenmode_data)


def _get_eigenmode(f, frequency, d, where, eig_vol, band_num, _kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom):
    return _meep._get_eigenmode(f, frequency, d, where, eig_vol, band_num, _kpoint, match_frequency, parity, resolution, eigensolver_tol, kdom)

def _get_eigenmode_Gk(emdata):
    return _meep._get_eigenmode_Gk(emdata)

def is_point_in_object(p, o):
    return _meep.is_point_in_object(p, o)

def is_point_in_periodic_object(p, o):
    return _meep.is_point_in_periodic_object(p, o)

def display_geometric_object_info(indentby, o):
    return _meep.display_geometric_object_info(indentby, o)

def get_eigenmode_coefficients_and_kpoints(*args):
    return _meep.get_eigenmode_coefficients_and_kpoints(*args)

def _get_array_slice_dimensions(*args):
    return _meep._get_array_slice_dimensions(*args)

AUTOMATIC = -1
CYLINDRICAL = -2
ALL = -1
ALL_COMPONENTS = Dielectric

# MPB definitions
NO_PARITY = 0
EVEN_Z = 1
ODD_Z = 2
EVEN_Y = 4
ODD_Y = 8
TE = EVEN_Z
TM = ODD_Z
PREV_PARITY = -1

inf = 1.0e20

from .geom import (
    Block,
    Cone,
    Cylinder,
    DrudeSusceptibility,
    Ellipsoid,
    FreqRange,
    GeometricObject,
    GyrotropicDrudeSusceptibility,
    GyrotropicLorentzianSusceptibility,
    GyrotropicSaturatedSusceptibility,
    Lattice,
    LorentzianSusceptibility,
    MaterialGrid,
    Matrix,
    Medium,
    MultilevelAtom,
    NoisyDrudeSusceptibility,
    NoisyLorentzianSusceptibility,
    Prism,
    Sphere,
    Susceptibility,
    Transition,
    Vector3,
    Wedge,
    check_nonnegative,
    geometric_object_duplicates,
    geometric_objects_duplicates,
    geometric_objects_lattice_duplicates,
    cartesian_to_lattice,
    lattice_to_cartesian,
    lattice_to_reciprocal,
    reciprocal_to_lattice,
    cartesian_to_reciprocal,
    reciprocal_to_cartesian,
    find_root_deriv,
    get_rotation_matrix,
)
from .simulation import (
    Absorber,
    Ldos,
    EnergyRegion,
    FluxRegion,
    ForceRegion,
    Harminv,
    Identity,
    Mirror,
    ModeRegion,
    Near2FarRegion,
    PML,
    Rotate2,
    Rotate4,
    Simulation,
    Symmetry,
    DftObj,
    DftFlux,
    DftForce,
    DftNear2Far,
    DftEnergy,
    DftFields,
    Volume,
    DiffractedPlanewave,
    after_sources,
    after_sources_and_time,
    after_time,
    at_beginning,
    at_end,
    at_every,
    at_time,
    before_time,
    combine_step_funcs,
    complexarray,
    dft_ldos,
    display_progress,
    during_sources,
    GDSII_layers,
    GDSII_prisms,
    GDSII_vol,
    get_center_and_size,
    get_eigenmode_freqs,
    get_electric_energy,
    get_energy_freqs,
    get_flux_freqs,
    get_fluxes,
    get_force_freqs,
    get_forces,
    get_group_masters,
    get_ldos_freqs,
    get_magnetic_energy,
    get_near2far_freqs,
    get_num_groups,
    get_total_energy,
    in_point,
    in_volume,
    interpolate,
    merge_subgroup_data,
    output_epsilon,
    output_mu,
    output_hpwr,
    output_dpwr,
    output_tot_pwr,
    output_bfield,
    output_bfield_x,
    output_bfield_y,
    output_bfield_z,
    output_bfield_r,
    output_bfield_p,
    output_dfield,
    output_dfield_x,
    output_dfield_y,
    output_dfield_z,
    output_dfield_r,
    output_dfield_p,
    output_efield,
    output_efield_x,
    output_efield_y,
    output_efield_z,
    output_efield_r,
    output_efield_p,
    output_hfield,
    output_hfield_x,
    output_hfield_y,
    output_hfield_z,
    output_hfield_r,
    output_hfield_p,
    output_png,
    output_poynting,
    output_poynting_x,
    output_poynting_y,
    output_poynting_z,
    output_poynting_r,
    output_poynting_p,
    output_sfield,
    output_sfield_x,
    output_sfield_y,
    output_sfield_z,
    output_sfield_r,
    output_sfield_p,
    py_v3_to_vec,
    quiet,
    scale_energy_fields,
    scale_flux_fields,
    scale_force_fields,
    scale_near2far_fields,
    stop_after_walltime,
    stop_on_interrupt,
    stop_when_fields_decayed,
    synchronized_magnetic,
    to_appended,
    vec,
    verbosity,
    when_true,
    when_false,
    with_prefix
)
from .source import (
    ContinuousSource,
    CustomSource,
    EigenModeSource,
    GaussianSource,
    IndexedSource,
    Source,
    SourceTime,
    check_positive,
    GaussianBeamSource,
)
from .visualization import (
    plot2D,
    plot3D,
    plot_fields,
    Animate2D
)
from .verbosity_mgr import (
    Verbosity
)

if with_mpi():
    try:
        from mpi4py import MPI
        MPI.Startup()
    except ImportError as e:
        print('\n**\n** failed to load python MPI module (mpi4py)\n**', e, '\n**\n')
        pass
    else:
# this variable reference is needed for lazy initialization of MPI
        comm = MPI.COMM_WORLD
        if am_master():
            Procs=comm.Get_size()
            (Major,Minor)=MPI.Get_version();
            print('Using MPI version {}.{}, {} processes'.format(Major, Minor, Procs));

        if not am_master():
            import os
            import sys
            saved_stdout = sys.stdout
            sys.stdout = open(os.devnull, 'w')

vacuum = Medium(epsilon=1)
air = Medium(epsilon=1)
metal = Medium(epsilon=-inf)
perfect_electric_conductor = Medium(epsilon=-inf)
perfect_magnetic_conductor = Medium(mu=-inf)
_t_start = wall_time()

def report_elapsed_time():
    print("\nElapsed run time = {:.4f} s".format(wall_time() - _t_start))

import atexit
atexit.register(report_elapsed_time)


def get_realnum_size():
    return _meep.get_realnum_size()

def create_structure_and_set_materials(cell_size, dft_data_list_, pml_1d_vols_, pml_2d_vols_, pml_3d_vols_, absorber_vols_, gv, br, sym, num_chunks, Courant, use_anisotropic_averaging, tol, maxeval, gobj_list, center, _ensure_periodicity, _default_material, alist, extra_materials, split_chunks_evenly, set_materials, existing_s, output_chunk_costs):
    return _meep.create_structure_and_set_materials(cell_size, dft_data_list_, pml_1d_vols_, pml_2d_vols_, pml_3d_vols_, absorber_vols_, gv, br, sym, num_chunks, Courant, use_anisotropic_averaging, tol, maxeval, gobj_list, center, _ensure_periodicity, _default_material, alist, extra_materials, split_chunks_evenly, set_materials, existing_s, output_chunk_costs)


